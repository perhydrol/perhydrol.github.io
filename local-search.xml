<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/post/0.html"/>
    <url>/post/0.html</url>
    
    <content type="html"><![CDATA[<table><tbody><tr class="odd"><td>title:简单线性回归的</td></tr><tr class="even"><td>tags:统计学习</td></tr><tr class="odd"><td>abbrlink:7fda15c2</td></tr><tr class="even"><td>date:2024-04-19 20:55:03</td></tr><tr class="odd"><td>math:true</td></tr></tbody></table><h1 id="简单线性回归">简单线性回归</h1><p>什么是简单线性回归？根据《统计学习导论》一书，是指一种非常简单地根据单一预测变量X 预测定量响应变量 Y 的方法。也就是 <spanclass="math display">\[Y\approx\beta _{0}+\beta_{1}X\]</span></p><p>注意，本文<strong>不会</strong>专注于概念的公式和计算，我只想搞定以下目标：</p><ol type="1"><li>如何进行简单线性回归</li><li>如何评估回归的拟合质量    - 参数的拟合质量    -模型整体的拟合质量</li><li>预测变量和响应变量之间是否有关系？如何评估他们之间的关系</li><li>哪些预测变量显著影响着响应变量？</li></ol><h2 id="如何进行简单线性回归">如何进行简单线性回归</h2><p>我们都学过最小二乘法拟合一条直线，简单来说就是找到一条直线，使所有点到直线的距离最小。</p><p>让我们专业一点： <strong>残差</strong>：第 i 个观测到的响应值到第 i个用线性模型预测的响应值之间的差距。公式如下 <spanclass="math display">\[e_i=y_i-\hat{y_{i}}\]</span></p><p>但很明显，这个公式算出来的结果有正有负，也就是预测可能偏大偏小，因此我们加个平方形成<span class="math display">\[e^2_i=(y_i-\hat{y_{i}})^2\]</span></p><p>自然，我们得到将所有观测到的响应点到预测直线的“距离”用<strong>残差平方和（RSS）</strong>来评估 也就是说最小二乘法目标是使 RSS 最小。接下来，调包运算即可。</p><h2 id="如何评估回归的拟合质量">如何评估回归的拟合质量</h2><h3 id="参数的拟合质量">参数的拟合质量</h3><p>一般而言，我们假设 X 和 Y 之间的真实关系表示为 <spanclass="math inline">\(Y=f(X)+\varepsilon\)</span> 。其中 <spanclass="math inline">\(f(X)\)</span>是我们具体要求的函数，在简单线性回归中为 <spanclass="math inline">\(Y\approx\beta _{0}+\beta_{1}X\)</span> ，<spanclass="math inline">\(\varepsilon\)</span> 是随机误差项。</p><p>如何评估参数的估计值偏离真实值的大小？</p><h4 id="标准误差">标准误差</h4><p>我们通过计算<strong>标准误差（标准误SE）</strong>来回答这个问题，它将告诉我们估计值偏离实际值的平均量。我注意到大家一提到标准误，似乎默认为<strong>均值的标准误</strong>也就是如下公式<span class="math display">\[SE(\hat{\mu})^2=\frac{\sigma^2}{n}\]</span></p><p>然而，实际上所有参数都有自己的标准误，比如 <spanclass="math display">\[SE(\hat{\beta_1}  )^2=\frac{\sigma^2}{\sum_{i=1}^{n}(x_i-\bar{x} )^2 }\]</span></p><p><span class="math display">\[SE(\hat{\beta_0}  )^2=\sigma^2[\frac{1}{n}+\frac{\bar{x}^2 }{\sum_{i=1}^{n}(x_i-\bar{x} )^2 }]\]</span></p><p>同时，这些公式严格成立需要：每个观测值的误差项独立，并且具有相等的方差</p><h3 id="模型整体的拟合质量">模型整体的拟合质量</h3><p>有两个量来评估：RSE和 <span class="math inline">\(R^2\)</span>统计量</p><h3 id="rse">RSE</h3><p>RSE是对随机误差项的标准偏差的估计。上面的标准误差是评估参数估计值离实际值的平均量，而RSE 是模型预测值会偏离真正回归直线的平均量。(RSS 是残差平方和) <spanclass="math display">\[RSE=\sqrt{\frac{RSS}{n-2}}\]</span></p><h3 id="r2-统计量">R^2 统计量</h3><p><span class="math inline">\(R^2\)</span> 由两个统计量进行计算：TSS 和RSS。RSS 已经知道了是指残差平方和，TSS 是什么呢？</p><p><span class="math display">\[TSS=\sum (y_i-\bar{y} )^2\]</span></p><p>TSS 可以认为是不假设任何模型，就使用 y的平均值当作所有预测值所产生的偏差。</p><p>而 <span class="math inline">\(R^2\)</span>是如下定义的，可以理解为引入预测变量后能减少只使用 <spanclass="math inline">\(\bar{y}\)</span> 进行预测的误差占原误差的比例。<span class="math display">\[R^2=\frac{TSS-RSS}{TSS}\]</span></p><h2id="预测变量和响应变量之间是否有关系">预测变量和响应变量之间是否有关系？</h2><p>我们可以对系数进行假设检验，也就是对以下<strong>零假设</strong>和<strong>备选假设</strong>进行检验</p><p>零假设 <span class="math inline">\(H_0\)</span> ：X 和 Y之间没有关系（ <span class="math inline">\(\beta_1=0\)</span> ）</p><p>备选假设 <span class="math inline">\(H_\alpha\)</span> ：X 和 Y之间有一定的关系（ <span class="math inline">\(\beta_1\ne0\)</span>）</p><p>对于以上假设，我们先计算 t 统计量，进而计算 p 值 <spanclass="math display">\[t=\frac{\hat{\beta_1}-0}{SE(\hat{\beta_1})}\]</span></p><p>t 统计量衡量了 <span class="math inline">\(\hat{\beta_1}\)</span>偏离 0 的标准偏差。通过查表或直接调包计算出 t 统计量对应的 p 值。</p><p>当 p 值小于 5% 或 1%时，可以推测预测变量和响应变量之间存在关联，也就是拒绝零假设。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>阅读</title>
    <link href="/post/69a58a0b.html"/>
    <url>/post/69a58a0b.html</url>
    
    <content type="html"><![CDATA[<p>本文的内容来自<ahref="https://zhuanlan.zhihu.com/p/519549411?utm_id=0">如何阅读（用 Anki渐进阅读）</a></p><p>学习来自于重复，为了实现更频繁的重复，阅读或许可以划分为两个阶段： 1.读书并批注 2. 写一篇“读后总结”以进一步研究，并制作抽认卡</p><h2 id="阅读并批注">阅读并批注</h2><p>阅读时拿根笔，在书上写写画画。这将为之后写读后总结提供提示与引导。一般来说，除了简单的画条线，还有更好的方法——写下批注，说明为什么被这些吸引了注意力；如何处理这些批注，是想进一步研究还是句式漂亮或其内容提纲挈领。可以试着总结一些小符号来进一步帮助你加快批注，并且有助于日后的总结。</p><p>写下你的想法，对句子进行简单的评价或提出你自己的问题。让他们引导或逼迫你进一步思考书中的内容。</p><p>最后，每读完一章就写下一章的总结，这时不写以后你也不会写了。</p><h2 id="读后总结">读后总结</h2><p>在阅读完书的第二天，或者尽快开始写下你的读后总结。翻开书，浏览你的所有注释。一个可行的总结模板如下：- 评论 - 摘要 - 引用 - 问题 - 自己的想法</p><p>评论和摘要可以结合起来，抄下一段话，著名页码，写下你的想法。这可以是赞同也可以是质疑，无论如何，这都是自己的思考。</p><p>引用部分，将好的引用归纳为 Anki 卡片，开始重复学习。</p><p>对于每一个问题，研究它并制作更多的 Anki 卡片。</p><p><strong>让我试试这个方法好不好使，感受之后再写下我对这篇介绍阅读方法的文章的“我的总结”</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>感想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高效学习</title>
    <link href="/post/d078b5cc.html"/>
    <url>/post/d078b5cc.html</url>
    
    <content type="html"><![CDATA[<p>本文为 <ahref="https://github.com/zijie0/HumanSystemOptimization">HumanSystemOptimization</a>的总结。</p><h2 id="大脑健康与学习">大脑健康与学习</h2><h3 id="睡眠">睡眠</h3><p>这一段内容主要介绍了睡眠的原理，好处和实践方法</p><ul><li>睡眠的原理是基于我们的内在生物钟，受光照和体温的影响，控制我们体内各类化学物质的变化，影响我们的内在状态和外在行为</li><li>睡眠的好处包括提升生理健康如免疫，新陈代谢，以及心理健康如心情，专注能力等</li><li>睡眠的实践方法包括：<ul><li>起床后到外面接触阳光，持续 2-10 分钟</li><li>晚上尽量减少光源的接触，尤其是晚上 11 点到次日凌晨 4 点之间</li><li>如果不可避免需要在晚上接触光源，选择较低位置，暗淡的红光，或者使用blue blockers 眼镜</li><li>傍晚观察落日，有助于入睡</li><li>中午可以选择午睡或者其他非睡眠深度休息的方式</li><li>早上洗冷水澡，晚上锻炼身体，可以调节体温和生物钟周期</li><li>选择合适的饮食和药物因素，如中午吃低卡路里和含酪氨酸的食物，晚上吃富含色氨酸的食物，避免摄入太多咖啡因和褪黑素等</li><li>对于绝大多数人，保证 6-8 小时的睡眠时长是比较健康的</li></ul></li></ul><h3 id="fasting">Fasting</h3><p>介绍了 fasting 的背景和原理</p><ul><li>fasting是指在一定时间段内不摄入任何食物的做法，可以分为长时间的禁食和间歇性禁食（intermittentfasting）</li><li>fasting的原理是利用血糖水平的变化来控制身体的两种化学状态：吃饱了的状态和禁食的状态<ul><li>吃饱了的状态是指血糖含量较高的状态，此时身体会更活跃地进行细胞的复制和成长</li><li>禁食的状态是指血糖含量较低的状态，此时身体会更活跃地进行细胞的修复和清理（autophagy）</li></ul></li></ul><p>介绍了 fasting 的好处和实践方法</p><ul><li>fasting对身体有非常多的好处，包括：促进肝脏健康，胆汁酸代谢，炎症自愈，保持体重，提升brown fat储备（对健康有益），防止非酒精性脂肪肝，血糖控制，肠道健康等等</li><li>fasting 的实践方法有基础和高阶两个版本：<ul><li>基础：起床后至少 1 小时内不要吃东西，睡前 2-3小时不要吃任何东西</li><li>高阶：在一天中固定一个 8小时的进食窗口，其余时间不吃任何东西。一般比较合理的时间在 10-18 点或12-20 点</li></ul></li></ul><p>fasting 的注意事项有以下几点：</p><ul><li>尽量保证进食窗口时间的稳定性，否则会打乱生物钟</li><li>如果想尝试高阶fasting，建议逐渐切换进食习惯，每两天缩短一个小时的进食窗口</li><li>喝水，茶，咖啡（不加牛奶）等，并不会中断禁食。但一勺糖就会中断</li><li>晚饭后可以做一些轻量运动，加快血糖清理。也可以服用二甲双胍，黄连素等降血糖药物或食物</li><li>如果禁食期间觉得头晕，颤抖，可以喝一点盐水（可以加柠檬汁），缓解症状</li></ul><h3 id="饮食与消化道健康">饮食与消化道健康</h3><p>介绍了肠道的微生物群落与人体的免疫系统和情绪的关系</p><ul><li>肠道菌群可以影响血清素等神经递质的合成和释放</li><li>肠道菌群可以影响免疫系统的平衡和炎症反应</li><li>肠道菌群可以影响情绪和认知功能，如抑郁，焦虑，记忆等</li></ul><p>介绍了如何通过饮食来改善肠道菌群生态，提高菌群的多样性和健康</p><ul><li>推荐每天两次摄入天然发酵类食品，如酸奶，泡菜，酱油等</li><li>日常饮食以植物类食物为主，尽量避免深度加工食品和糖的摄入</li><li>谨慎使用抗生素和益生菌，因为它们可能会破坏肠道菌群的平衡</li><li>更推荐地中海饮食结构，即多摄入蔬果，坚果，豆类，全谷物，橄榄油等</li></ul><h3 id="心态与动力">心态与动力</h3><p>介绍了多巴胺系统的原理，以及如何利用它来形成健康，自律的生活方式</p><ul><li>多巴胺是一种影响我们动机，欲望和快乐的化学物质，受到不安，压力，沮丧等情绪的抑制</li><li>多巴胺水平的高低不仅取决于绝对值，还取决于相对变化量。当我们达到或超过预期目标时，多巴胺会释放；当我们未达到或低于预期目标时，多巴胺会减少</li><li>多巴胺的储备是有限的，如果过度消耗会导致耗尽和抑郁。因此需要避免过度刺激多巴胺系统的行为，如吸毒，赌博，色情等</li><li>多巴胺也具有叠加效应，如果同时进行多种快乐活动，会造成更大的多巴胺释放和后续低谷。因此需要避免同时进行多种快乐活动，如吃饭时看电视等</li></ul><p>建议通过间歇性且随机的奖励机制来维持多巴胺水平的差异性和可持续性</p><ul><li>通过随机化叠加因素的多少来实现多巴胺释放的差异性。比如在健身时随机决定是否要听音乐，是否要带手机等因素</li><li>通过间歇性给予奖励来实现多巴胺释放的可持续性。比如在完成一个任务后给自己一个小奖励，如吃一块巧克力，看一集剧等</li></ul><p>建议通过成长型思维来把努力过程本身当作一种奖励</p><ul><li>通过自我暗示，把学习，工作，运动等过程本身当作有趣，有益的活动，而不是为了完成后的奖励</li><li>通过正面的心理暗示，把错误，失败，挫折等当作学习成长的必要条件，而不是消极的评价</li></ul><p>建议通过自律，自我暗示来改变自身对各类活动的喜好</p><ul><li>通过暗示某种活动对我们健康的益处，来获取满足感，而不是借助于活动结束后的奖励。比如通过暗示fasting 对我们健康的益处，来获取满足感，而不是借助于 fasting结束后的大快朵颐</li><li>通过自律抵御高油盐食物的吸引力，并且自我暗示植物类食物对身体的好处，坚持一段时间，会觉得花椰菜也挺美味的</li></ul><h3 id="学习与专注">学习与专注</h3><p>介绍了学习的原理，以及如何利用神经可塑性来提高学习效率和质量</p><ul><li>学习的本质是神经元的重新连接，需要大脑处于一种学习的化学状态，即神经可塑性状态</li><li>神经可塑性状态需要两个条件：足够的专注度和犯错的信号<ul><li>专注度是指对某个任务或目标的持续关注和投入</li><li>犯错信号是指当我们尝试做一些事情，但没有达到预期目标时，身体会给大脑发信号，“我犯错了”</li></ul></li><li>犯错是进入学习状态的重要前提，也会激发多巴胺等化学物质的释放，促进神经元的改变<ul><li>多巴胺会提升我们对目标的渴求度和重要性</li><li>肾上腺素会提升我们的警觉度和注意力</li><li>乙酰胆碱会提升我们的专注度和记忆力</li><li>这些化学物质会激活神经元的可塑性，让它们更容易重新连接和适应新的信息和技能</li></ul></li><li>神经元的重连接主要是在休息和睡眠时发生<ul><li>在学习时，乙酰胆碱会标记需要改变的神经元</li><li>在休息和睡眠时，这些神经元会进行重新连接和强化</li><li>这个过程可以加速我们对新知识技能的掌握和巩固</li></ul></li></ul><p>介绍了如何达到理想的学习状态，以及如何提升专注度</p><ul><li>理想的学习状态除了神经可塑性的化学状态外，还需要注意其它的因素<ul><li>不要太放松以至于有些昏昏欲睡，也不要太紧张激动，无法控制自己拥有清晰的思考。这些也都跟我们体内的多巴胺，肾上腺素，乙酰胆碱，血清素，褪黑素等化学物质的水平</li><li>利用生理叹息来调节情绪，降低压力和警觉水平，让人感到更加平静，提升学习表现。生理叹息是指吸两口气，然后出一口长气的呼吸方式</li><li>保持成长型思维来应对错误，把错误当作学习成长的必要条件，而不是消极的评价。这样可以增加多巴胺的释放，提升学习动力和过程中的愉悦感</li><li>利用音乐，休息和 gap effect 来加强学习效果<ul><li>在学习时听一些有规律的节拍，在入睡时也播放同样的微弱节拍，能够提升学习和记忆的效果</li><li>一般在 90 分钟的学习后（人体生物钟的周期），可以选择进行 20分钟的休息（non sleep deep rest），也会加强学习的效果</li><li>Gap effect 是指在学习中随机停止 10秒钟，这些停止会在睡眠中加速“播放”，提升学习效果</li></ul></li></ul></li><li>提升专注度的方法是利用大脑中两种网络模式的协调，以及利用一些行动工具来影响专注度<ul><li>两种网络模式是指 Default network 和 Task networks<ul><li>Default network是指在我们不做任何事情时被激活的大脑区域，负责自我相关的思维，如回忆，想象，规划等</li><li>Task networks是指在我们专注于做某些事情时被激活的大脑区域，负责执行相关的任务，如计算，阅读，写作等</li><li>这两种网络模式像跷跷板一样，当一种模式被激活时另一种模式会被抑制。普通人的大脑能够很好地协调这两个模式，保持专注；而具有专注障碍（比如多动症）的人来说，这两者无法很好地进行协调，因此会出现无法专注的现象</li></ul></li></ul></li><li>多巴胺等化学物质可以影响这两种网络模式的协调，因此有些药物可以提升专注，但有副作用和风险<ul><li>Huberman教授表示，一方面多巴胺的刺激提升后都会带来多巴胺水平的低谷，另一方面这些药物也可能导致上瘾，对新陈代谢作用造成扰动，有很多负面影响。对长期的学习与记忆效果可能并没有提升作用。在之前介绍多巴胺的章节也有提到，应该谨慎使用这类药物，并严格控制使用频率不能过高</li><li>更好的方法是通过控制多巴胺系统，以及利用一些行动工具来影响专注度</li><li>通过控制多巴胺系统，指的是前面提到的通过间歇性且随机的奖励机制，以及成长型思维来维持多巴胺水平的差异性和可持续性，以及提升学习动力和过程中的愉悦感</li><li>利用一些行动工具来影响专注度，指的是以下几种方法：<ul><li>补充 Omega-3 EPA鱼油，这是神经细胞的组成原料之一，能够有效减轻抑郁，对治疗多动症（ADHD）也有帮助</li><li>通过身体其它部分释放运动，可以帮助提升注意力。比如作为神经科医生在开刀时，如果采用半蹲半站的姿态（运动释放），拿手术刀的手更稳定不容易颤抖。这让我想起以前读书时很多同学习惯转笔，现在工作了也有不少人喜欢玩指尖陀螺，或者站立办公，可能都是类似效果</li><li>限制视野范围，能够提升专注度。比如我们经常因为眼睛瞟到了任务栏上的消息提示闪动而分心，可以通过一些设置来进入“专注模式”</li><li>视线的高低也会影响神经状态，视线往下看会让神经系统偏向镇静，放松，甚至困倦，而视线向上则会让系统提升警惕。工作时一般至少把显示器放置在鼻子位置之上</li><li>大脑不擅长处理大量频繁的 contextswitch（上下文切换），典型的比如刷抖音，不同的信息以非常快的速度频繁切换，这对我们的注意力是有伤害作用的。2014年的一项研究表示，我们每天在手机上花费的时间应该少于 60分钟（青少年）/120 分钟（成年），以免引起注意力障碍问题</li><li>还有研究表明，17分钟的冥想，能够对大脑中的神经元做重新连接，永久地改善注意力。只要做一次就可以，完全可以尝试一下</li></ul></li></ul></li></ul><h3 id="大脑健康">大脑健康</h3><p>介绍了如何提升大脑健康和效能的一些方法</p><ul><li><p>首先是保证高质量的睡眠</p><ul><li>睡眠对大脑健康和学习效果有重要作用</li><li>睡眠可以清除大脑中的代谢废物和毒素</li><li>睡眠可以促进神经元的重连接和强化</li><li>睡眠可以调节情绪和压力水平</li><li>建议每天保证 7-9 小时的睡眠时间，并且遵循自然光周期</li></ul></li><li><p>其次是进行有氧运动</p><ul><li>有氧运动对大脑直接帮助最大，提升心肺功能，支持大脑供能</li><li>有氧运动可以增加血液流量和氧气输送到大脑</li><li>有氧运动可以促进新生神经元的生成和存活</li><li>建议每周 150-180 分钟的有氧训练</li></ul></li><li><p>再次是摄入一些对大脑有益的食物或补充剂</p><p>以下是一些对大脑健康有帮助的食物，其中前三点是比较重要的，后面的部分涉及的研究没有那么多</p><ul><li>Omega-3 EPA鱼油，是神经细胞的组成原料之一，且一般人都容易摄入不足。多吃鱼，牡蛎，鱼子酱，奇亚籽，核桃，大豆。一天至少摄入1.5 克，理想情况需要 3 克以上。不喜欢吃鱼的话可以辅助摄入鱼油</li><li>磷脂酰丝氨酸，也对认知能力有帮助。通过鱼，肉类，卷心菜来摄入</li><li>乙酰胆碱，重要的神经调质，提升注意力。摄入胆碱的重要来源是鸡蛋，尤其是蛋黄。土豆，坚果，水果中也含有，虽然没有蛋黄中的含量那么丰富。可以通过Alpha-GPC 等补充剂来获取</li><li>肌酸，尤其对于不吃肉的人，一天需要摄入 5 克左右</li><li>花青素，在蓝莓，黑莓，葡萄等食物中有提供。可以降低 DNA损伤，缓解认知下降等问题。大约每天需要 60-120 克蓝莓的补充</li><li>谷氨酰胺，可以通过牛肉，鸡肉，鱼肉，鸡蛋，大豆，卷心菜，菠菜，芹菜等食物来摄取。提升大脑在缺氧（高海拔地区）下的表现，还能够抑制对糖的需求</li><li>水，钠，钾，镁等电解质是神经元信号传递所需的基础元素，需要保证</li></ul><p>还可以通过提升大脑代谢活跃度来增加对某种食物的喜好</p><ul><li>大脑对各种食物喜好进行判断的三个渠道是：味觉判断，营养成分的下意识判断和多巴胺系统的判断</li><li>多巴胺系统的判断是指我们可以通过提升大脑代谢的活跃度来增加对某种食物的喜好。比如你如果不喜欢吃鱼，一种方法是你可以把鱼跟你平时爱吃的食物一起吃；另一种是给自己足够的心理暗示，说服自己吃鱼是有益身体健康的。通过这两种办法，你都可以让大脑释放多巴胺，从而逐渐提升对鱼类食物的喜好程度</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>客观合理地期待星空（Starfield)——为什么我相信 &quot;It just works.&quot;</title>
    <link href="/post/b6d2dc63.html"/>
    <url>/post/b6d2dc63.html</url>
    
    <content type="html"><![CDATA[<p>星空直面会结束了，45min的干货，基本展示了游戏的每一个模块。没有看的可以看看B站的搬运<ahref="https://www.bilibili.com/video/BV15u4y1o7rx/?p=1">【中文字幕】星空Starfield直面会全流程)</a>。</p><p>总共有三个部分：可以预计有哪些问题、明明有这么多问题我们为什么选择相信星空、我期待星空有哪些内容。</p><hr /><h2id="聊聊为什么可能褒姒但概率比较低">聊聊为什么可能褒姒但概率比较低</h2><p>2020年后，有一款游戏是你在每一个3A大作预告里一定有人提的——《赛博朋克2077》。直接引爆了玩家对一众游戏厂商画大饼的不信任。它已经成为一个里程碑，从它之后的每一款3A大作或多或少都有问题，我可以举出一大堆：《战地2042》、《木卫四协议》（头几天也卡）、《老头环》（很多人首日闪退）……要多少有多少。很明显，3A大作的体量已经带来了灾难的管理难度，方方面面庞大的资金和人力、时间、物力的协调，生产函数已经发生了改变。</p><p>让我们将时间拨回2020，那个波兰蠢驴蓄势待发的年份。简单比较一下《赛博朋克2077》和《星空》的区别。分析一下“为什么你不能将《赛博朋克2077》直接对比《星空》”。</p><p>STAR模型，情境(situation)、目标（target）、行动(action)、结果(result)。</p><h3 id="情境">情境</h3><p>波兰蠢驴：《巫师3》空前的成功，《赛博朋克2077》被给予厚望，玩家翘首以待，那时谁敢说“褒姒”谁就“等死”。</p><p>B社：《辐射76》的阴影。Xbox唯一还有戏的护航者，一家跨国巨头部门的存亡一战；一家落寞游戏公司的孤注一掷。老玩家天天叫唤“褒姒”，吹的牛没人相信。</p><h3 id="目标">目标</h3><p>波兰蠢驴：玩家可以和游戏内每一位NPC独特交流（2020年波兰蠢驴就研发GPT啦，笑），系统，纵横交错多条线路，主角的不同帮派声望可以影响不同帮派对其的态度，每一处都可以进行自由探索，可以进入各处房屋，游戏优化，PS4畅玩。</p><p>B社：《赛博朋克2077》没实现的事情已经被《上古卷轴：天际》超级简化实现了，代价是少量的NPC、少量的房屋，每次加载都要读图。（老滚5为什么是神）《星空》除了飞船没做过，其他都是《辐射4》无敌MAX 版。</p><h3 id="行动">行动</h3><p>波兰蠢驴：超级宣发，年轻人的第一款3A大作。跳票，没人会记得按时发售的垃圾游戏。</p><p>B社：半年憋不出一个宣传片。几年没有作品，除了时代遗老，国内无人问津。跳票，跳票，陶德跳票时说话都发抖了。</p><h3 id="结果">结果</h3><p>波兰蠢驴：《赛博朋克2077》一款不错的游戏，硬是被过度宣发和无数BUG毁了。开启3A 大作崩坏时代。不停修复，游戏已经不错但口碑无法挽回。</p><p>B社：“褒姒”待定，薛定谔的猫。</p><p><strong>综上，可以窥见《星空》首发肯定有问题。但完全照搬《赛博朋克2077》的情况不恰当。有微软的监督与压力，《辐射76》阴影带来的小心谨慎，最后再考虑到直面会的游戏体量。褒姒有可能，但没有那么高。</strong></p><h1 id="泼冷水可以预见有哪些问题">泼冷水——可以预见有哪些问题</h1><h2 id="bug">BUG</h2><p>这几年的大作就没几个是首发无BUG的，有开创历史的《赛博朋克2077》和连外挂都放弃了的《战地2042》，哪怕是《塞尔达：王国之泪》首日也无法流畅运行。</p><p>那么，B社和微软这两大BUG大厂强强联手，首发必定BUG漫天。<ahref="https://www.bilibili.com/video/BV1T8411t7Dv/">《上古卷轴》巨人航空</a></p><figure><img src="https://s3.bmp.ovh/imgs/2023/06/12/7d68c00f5f77defb.jpg"alt="你一定不陌生" /><figcaption aria-hidden="true">你一定不陌生</figcaption></figure><h2 id="颗星球">1000颗星球</h2><p>B社！陶德！1000颗星球！《辐射3》有200个结局！“看见那座山了吗？你可以爬上去”！Fallout76 is 4x the size of Fallout 4！</p><p>客观的说，吹牛可不是B社独家，波兰蠢驴的史诗巨作——《赛博朋克2077》也声称“无脚本演出”。毕竟你在发布会不整点噱头真没人看你。</p><p>现在大家都知道，技术上限就那样，GPT和英伟达的H100才碰到了全实时剧情的门槛，这还是这两年刚刚出的技术，等应用在3A大作上还早。你可以期待任何东西，就不应该期待这1000颗星球（题外话，英伟达实时生成的那段视频效果真的不错，我很期待业界发展<ahref="https://www.bilibili.com/video/BV1om4y1x7x8/">将AI加入游戏开发！英伟达发布GH200超极计算机</a>）</p><h2 id="不算出色的画质和射击手感">不算出色的画质和射击手感</h2><p>画质和手感从来不是B社的强项，我最担心出现“画质和顽皮狗（最后生还者2）比，射击手感和使命召唤比”的要命评价。</p><p>客观的来说，画质相较B社自己的前作肯定是巨大的提升，射击手感相较《辐射4》必然有所改进，但你要是玩田忌赛马式的比较，我只能说“确实！”，不然呢？确实比不了啊。但这会影响我继续捡垃圾吗？ε=(o｀ω′)ノ</p><h2 id="每颗星球都十分巨大可能吗">每颗星球都十分巨大？可能吗？</h2><p>先不说超大星球的工作量，就是真有1000颗超大星球，150G的游戏它塞得下这么多东西嘛？知名二字开放世界游戏「原神」，目前就4个大地图，PC端已经30G了，要是「星空」每颗星球大小相当于「原神」一个国家的大小，这游戏储存大小没法玩了好吧。除非......它学Minecraft，980颗星球随机拼接地图，实时生成地图确实有可能。但我不太看好，估计980颗星球相当于980个大型地牢比较符合实际。</p><hr /><h1id="信陶爱陶等陶为什么我依旧期待星空">信陶，爱陶，等陶——为什么我依旧期待《星空》</h1><p><strong>因为它是 Bethesda 的最新力作，那个制作了《上古卷轴：天际》的Bethesda，那个即使《辐射4》是“一坨”我也玩的不亦乐乎的Bethesda</strong></p><p>我很难向没玩过B社作品的玩家解释，为什么B社的开放世界如此独特。或许只有B社自己的那句，“做你自己，这是属于你的故事”才最贴切。</p><blockquote><p>create any character you want and explore with unparalleled freedomas you embark on an epic journey</p></blockquote><h2id="都是b社了这你能不打个mod吗">都是B社了，这你能不打个MOD吗！？</h2><p>乔布斯有一句名言：“顾客不知道自己想要什么（People don't know whatthey want）。”但我要说——“游戏真的会自己长出来！” <imgsrc="https://s3.bmp.ovh/imgs/2023/06/12/6076998d94f4a97b.png"alt="只有 Minecraft 才能与之抗衡" /></p><p>从你进入游戏的一瞬间，鼠标能触碰的么一个点，MOD都能修改。玩腻了《辐射4》的铁管武器？打个MOD，现代武器任君选。<imgsrc="https://s3.bmp.ovh/imgs/2023/06/12/07cf0a8eab0f248c.png" /></p><h2 id="连bug都能修">连BUG都能修！</h2><p>我不太担心B社的BUG，或者是B社为什么有胆量留着一众祖传BUG发售，都是MOD社区给它惯的╰（‵□′）╯<imgsrc="https://s3.bmp.ovh/imgs/2023/06/12/15b35ed35a7ebeaf.png" /></p><h2 id="我想要二次元oo">我想要二次元o(〃＾▽＾〃)o</h2><p><imgsrc="https://s3.bmp.ovh/imgs/2023/06/12/2cbdb73258ee5929.png" /></p><p>我想瑟瑟……，咳咳，前面的区域自己去探索吧。</p><h2 id="这些我们都做过熟练了">这些我们都做过，熟练了</h2><p>看似很多内容，很多东西在《上古卷轴》和《辐射》都有影子。我发现很多人都希望3A大作与大公司能有巨大的创新，我认为这不合理。大公司已经没有勇气去花大代价试错了，特别是Xbox已经是主机市场的弱者，B社的口碑才好一点点。将自己从未尝试的领域作为主打产品就是下一个《红霞岛》，我之所以对星空有信心，正是因为我没看见陶德准备整大活，1000颗星球除外，没人会期待这个。其他的部分，都是B社的老本行，熟练了。</p><hr /><h1 id="我期待星空什么">我期待星空什么？</h1><p>很明显，B社从《辐射4》吸取的教训，比如：改进枪械手感（找了做DOOM的同事帮忙）、主角取消配音（这确实不是退步，当年辐射4主角加入配音导致一种MOD无法正常工作）、点的技能终于又能影响剧情了（这是很多人从《辐射：新维加斯》转到《辐射4》最不满意的地方，辐射4主角点口才技能只能用来讨价还价）</p><h2id="可能会出现的随机地图这是我的推测">可能会出现的随机地图，这是我的推测</h2><p><img src="https://s3.bmp.ovh/imgs/2023/06/12/21303c1d779118e6.png" /><imgsrc="https://s3.bmp.ovh/imgs/2023/06/12/f08423c56ae5fffd.png" /></p><p>这似乎是同一个地点，但出现了不同的建筑。我推测类似 Minecraft里的沙漠神殿和丛林神庙这种建筑机制，在特定类型的地方可能随机生成建筑。不过我推测，B社将建筑和地点分成了可以随机生成和不可随机生成两种，小建筑随机生成，大建筑与剧情相关固定地点。</p><hr /><p>最后，为了防止话说得太满，以一句“星空！褒姒！”结尾吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>感想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>检查字符串是否为合法文件路径-Python3</title>
    <link href="/post/a0f6072d.html"/>
    <url>/post/a0f6072d.html</url>
    
    <content type="html"><![CDATA[<p>在 Python3中如何检查一个字符串能否成为文件路径？即使这个文件现在还不存在，但当你要按路径创建时它能创建成功。显然os.isdir() 等函数不能满足我们的要求，因为 <code>os.isdir()</code>要求文件已经存在。我的笔记将解决这个问题。 <span id="more"></span></p><h2 id="定义合法">定义“合法”</h2><p>什么样的路径是合法的呢？一般来说，合法有效的文件路径有以下几点： 1.不包含空字节（即 Python 中的 ）。这是所有 POSIX 兼容文件系统的硬性要求。2. 路径中不含有超过 255个字符（&lt;=255）的组件，简单来说就是文件夹和文件的名字不超过 255个字符 3. 在 Windows 中文件路径的根会是一个驱动器（比如：C: ) 4. 在POSIX 中文件路径的根会是<code>根目录</code> ( / )</p><h2 id="实现目标">实现目标</h2><ol type="1"><li>检验字符串的合法性</li><li>避免不必要的写入，即先试图创建文件再校验的实现方式</li><li>在路径位于慢速驱动器时依旧能快速检验，以防止多次检验造成的卡顿（比如将网络挂载为驱动器进行访问）</li></ol><h2 id="一些-python-知识">一些 Python 知识</h2><h3 id="os.stat-和-os.lstat">os.stat() 和 os.lstat()</h3><blockquote><p>获取文件或文件描述符的状态。在所给路径上执行等效于 stat()系统调用的操作。path 可以是字符串类型，或（直接传入或通过 PathLike接口间接传入的） bytes 类型，或打开的文件描述符。返回一个 stat_result对象。—— Python 3.11.1 文档</p></blockquote><blockquote><p>在给定路径上执行本函数，其操作相当于 lstat() 系统调用，类似于 stat()但不跟踪符号链接。返回值是 stat_result对象。在不支持符号链接的平台上，本函数是 stat() 的别名。从 Python 3.3起，此功能等价于 os.stat(path, dir_fd=dir_fd, follow_symlinks=False)。—— Python 3.11.1 文档</p></blockquote><p>但我们的目标不是这个，我们的目标是它将会抛出的异常： 1.FileNotFoundError ：如果路径组件不存在 2. TypeError：路径存在，但包含空字节 3. OSError ：路径存在，但字符长度超过 255 字节4. winerror : 在 Windows 下,winerror 属性为 123 （即 ERROR_INVALID_NAME）文件名、目录名或卷标语法不正确</p><p>比如 /etcc/aaaaa....aaaa (256 个 a 且不存在 etcc 目录 ) 会抛出<code>FileNotFoundError</code> 但 /etc/aa....aaa (256 个 a 且存在 etc目录) 会抛出 <code>OSError</code>。</p><p>总结一下，<code>lstat()</code>会优先检查路径是否存在，然后是文件是否存在。注意，目录或者说文件夹也是文件。也就是说，我们保证路径存在就可以检查文件的合法性。</p><h2 id="算法规划">算法规划</h2><ol type="1"><li>将路径拆分为路径组件（'/etc/apt/' 变成 ['etc','apt']）</li><li>在一定存在且访问迅速的路径下调用 os.stat()对路径判断。根目录或<code>%HOMEDRIVE%</code>（Windwos 安装的驱动器，比如C:）是一个不错的选择（os.stat('/'+'etc'))</li><li>不停尝试，利用分治的思想，部分合法组成的大问题也合法</li></ol><h2 id="开始实现">开始实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> errno,os,sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">IsPathnameValid</span>(<span class="hljs-params">pathname:<span class="hljs-built_in">str</span></span>)-&gt;<span class="hljs-built_in">bool</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;检验传入的字符串是否为文件路径</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        pathname (str): 可能是文件路径的字符串</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Returns:</span><br><span class="hljs-string">        bool: True 为符合</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    ERROR_INVALID_NAME = <span class="hljs-number">123</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(pathname,<span class="hljs-built_in">str</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> pathname:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <br>        _,pathname=os.path.splitdrive(pathname)<br><br>        root_dirname=os.environ.get(<span class="hljs-string">&#x27;HOMEDRIVE&#x27;</span>,<span class="hljs-string">&#x27;C:&#x27;</span>) <span class="hljs-keyword">if</span> sys.platform==<span class="hljs-string">&#x27;win32&#x27;</span> <span class="hljs-keyword">else</span> os.path.sep<br>        <span class="hljs-keyword">assert</span> os.path.isdir(root_dirname)<br><br>        root_dirname=root_dirname.strip(os.path.sep)+os.path.sep<br><br>        <span class="hljs-keyword">for</span> pathname_part <span class="hljs-keyword">in</span> pathname.split(os.path.sep):<br>            <span class="hljs-keyword">try</span>:<br>                os.lstat(root_dirname+pathname_part)<br><br>            <span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> exc:<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(exc,<span class="hljs-string">&#x27;winerror&#x27;</span>):<br>                    <span class="hljs-keyword">if</span> exc.winerror==ERROR_INVALID_NAME:<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">elif</span> exc.errno <span class="hljs-keyword">in</span> &#123;errno.ENAMETOOLONG,errno.ERANGE&#125;:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">except</span> TypeError <span class="hljs-keyword">as</span> exc:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="来源">来源</h2><p>https://stackoverflow.com/questions/9532499/check-whether-a-path-is-valid-in-python-without-creating-a-file-at-the-paths-ta/9532586#9532586</p>]]></content>
    
    
    
    <tags>
      
      <tag>工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX 表格教程（tabularx 与自动换行、自动计算列宽）</title>
    <link href="/post/a178f8a9.html"/>
    <url>/post/a178f8a9.html</url>
    
    <content type="html"><![CDATA[<p>LaTeX的表格排版总是痛苦的，特别是你碰见了表格单元是由一段一段的文字构成的时候，表格排版会痛不欲生。在这种条件下，我要介绍tabularx包来帮助我们实现<strong>表格内自动换行与自动计算列宽</strong>，它能帮助我们缓解痛苦，愉快工作。<span id="more"></span> ## 在一切开始之前 1. tabularx 有用吗？tabular 不够好吗？</p><p>首先，tabularx 与 tabular 不是替代关系。并且没有一定要使用 tabularx的理由，它只是提供了自己的改进功能，帮助我们在某些情况下更快的编写表格。</p><ol start="2" type="1"><li>什么时候 tabularx 更好用？</li></ol><p>当你需要计算相对于总宽度的列宽时，tabularx更加好用。请注意，如果你的列宽很短且不包含换行符，则使用 tabularx不会获得任何好处。你可以使用常规 p 或 wl 说明符的 tabular来固定列的宽度。</p><ol start="3" type="1"><li>有类似的例子吗？</li></ol><ul><li>表格内有大段的文字时</li><li>表格有几个相等宽度的列，并且内部需要换行</li><li>已经不想去计算表格宽度的时候</li></ul><h2 id="可恶的表格与可爱的表格">可恶的表格与可爱的表格</h2><figure><img src="https://s3.uuu.ovh/imgs/2022/12/11/af34daa77458d931.png"alt="可爱的表格（简单）" /><figcaption aria-hidden="true">可爱的表格（简单）</figcaption></figure><p>上面的表格构成简单，简单编写后就很好看。无论内容是否简练，至少文字清晰。但下面这个表格就不行了。</p><figure><img src="https://s3.uuu.ovh/imgs/2022/12/11/a7742d43d63b46b3.png"alt="可恶的表格（复杂）" /><figcaption aria-hidden="true">可恶的表格（复杂）</figcaption></figure><p>表格内容多，格式复杂。最重要的是在要求表格为文字宽度后，内容根本看不清楚。</p><p>对于 tabular 教程，知乎有一篇不错。学会 tabular 可以更快地掌握tabularx。当然，不会 tabular 不影响你继续看下去。（<ahref="https://zhuanlan.zhihu.com/p/406538024">保姆级LaTeX教程|插入表格</a>）</p><p>在开始之前，我先推荐赶时间的同学们用下面这个网站自动化生成表格吧，使用tabular 完成简单的表格是够用的。（<ahref="https://www.tablesgenerator.com/">Tables Generator</a>）</p><p>少说废话，我们开始吧！</p><h2 id="tabularx-使用">tabularx 使用</h2><p>从一个简单的例子开始吧。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;tabularx&#125;&#123;0.8<span class="hljs-keyword">\textwidth</span>&#125; &#123; <br>  | &gt;&#123;<span class="hljs-keyword">\raggedright</span><span class="hljs-keyword">\arraybackslash</span>&#125;X <br>  | &gt;&#123;<span class="hljs-keyword">\centering</span><span class="hljs-keyword">\arraybackslash</span>&#125;X <br>  | &gt;&#123;<span class="hljs-keyword">\raggedleft</span><span class="hljs-keyword">\arraybackslash</span>&#125;X <br>  | &#125;<br>  <span class="hljs-keyword">\hline</span><br>  abc <span class="hljs-built_in">&amp;</span> edf <span class="hljs-built_in">&amp;</span> ghi<span class="hljs-keyword">\\</span><br>  <span class="hljs-keyword">\hline</span><br>  edf <span class="hljs-built_in">&amp;</span> abc <span class="hljs-built_in">&amp;</span> ghi<span class="hljs-keyword">\\</span><br>  <span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\end</span>&#123;tabularx&#125;<br></code></pre></td></tr></table></figure><p>结果如下图。</p><p><imgsrc="https://s3.uuu.ovh/imgs/2022/12/11/21c95b1758fa9e1d.png" /></p><p>和 tabular表格一样，整个表格环境从<code>\begin&#123;tabularx&#125;</code>开始，于<code>\end&#123;tabularx&#125;</code>结束。与tabular不同，第二个参数由大括号包裹，设置整个表格的宽度。在本例中，宽度为 0.8的文字宽度；当然，这个文字宽度肯定不是 abc egf ghi的宽度，<code>\textwidth</code>是整个页面中一行满满的文字的宽度，而 0.8自然代表只有 80%的宽度啦，你还可以是<code>0.5\textwidth</code>或者干脆占满宽度<code>\textwidth</code>（可别傻乎乎的写个<code>1\textwidth</code>，但也许也行？）。</p><p>那么，后面的<code>| &gt;&#123;\raggedright\arraybackslash&#125;X</code>是什么呢？让我们进入tabularx 的关键 X 吧！</p><h2 id="x">X</h2><p>如果你学会了tabular，你一定知道<code>&#123;|l|c|r|&#125;</code>是什么意思。不会也没关系，我教你啊。</p><p>我们用 <code>|</code>产生表格中的竖线，而<code>l</code>是要求这一列左对齐，<code>c</code>是居中对齐，<code>r</code>是右对齐。那么，<code>&#123;|l|c|r|&#125;</code>表示，表格有三列，从左到右依次是：左对齐、居中对齐、右对齐。同时，表格最外围的竖线和表内的竖线都要手动用<code>|</code> 产生，如果写成了 <code>&#123;l|c|r&#125;</code>的话，表格最外面的边框是不存在的！</p><p><code>tabularx</code>兼容以上写法，同时定义了一个新的字母—— 大写的<code>X</code>。使用 X指定的列，将会自动换行并向左对齐。那么，向右对齐呢？居中对齐呢？</p><p>我们知道<code>\raggedrigh</code>和<code>\centering</code>分别对应了向<strong>左</strong>对齐（参差不齐的右边即左对齐）、居中对齐。但在tabularx 中不能直接使用，他们会破坏换行符<code>\\</code>。为此，tabularx定义了 <code>\arraybackslash</code>来解决这个问题。使用方法就是直接加在后面，比如<code>&gt;&#123;\raggedright\arraybackslash&#125;X</code>就是进行<strong>左</strong>对齐，<code>&gt;</code>和<code>&#123;&#125;</code>不能少！</p><p><strong>每一个 tabularx 表格至少要有一个 X 列！</strong>虽然兼容l,c,r 写法，但纯 l,c,r 组成的 tabularx 表格会出错的！</p><h2 id="单元格与横线">单元格与横线</h2><p>每一个单元格使用<code>&amp;</code>分开，空格不是必须的。<code>abc&amp;def</code>和<code>abc &amp; def</code> 的效果一致。换行使用 <code>\\</code>完成，但每一行之间的横线不会自动生成，使用<code>\hline</code>手动生成吧！</p><p>如果要希望横线只占满几个格子，请使用<code>\cline&#123;begin-end&#125;</code>代替<code>\hline</code>。比如<code>\cline&#123;2-3&#125;</code>将只在从左向右数第2、3 格下产生横线。</p><h2 id="标题与表格居中">标题与表格居中</h2><p>tabularx 表格是可以嵌入 tabular表格中的！没想到吧😀。这波是齐心努力，做大做强。</p><p>位于内部的表格最好用<code>&#123;&#125;</code>包裹起来。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;table&#125;[]<br>  <span class="hljs-keyword">\centering</span><br>  <span class="hljs-keyword">\caption</span>&#123;0.8 textwidth&#125;<span class="hljs-keyword">\label</span>&#123;tab:dummy-1&#125;<br>  &#123;<br>    <span class="hljs-keyword">\begin</span>&#123;tabularx&#125;&#123;0.8<span class="hljs-keyword">\textwidth</span>&#125; &#123;<br>        | &gt;&#123;<span class="hljs-keyword">\raggedright</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        | &gt;&#123;<span class="hljs-keyword">\centering</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        | &gt;&#123;<span class="hljs-keyword">\raggedleft</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        |&#125;<br>      <span class="hljs-keyword">\hline</span><br>      abc <span class="hljs-built_in">&amp;</span> edf <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>      <span class="hljs-keyword">\hline</span><br>      edf <span class="hljs-built_in">&amp;</span> abc <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>      <span class="hljs-keyword">\hline</span><br>    <span class="hljs-keyword">\end</span>&#123;tabularx&#125;<br>  &#125;<br><span class="hljs-keyword">\end</span>&#123;table&#125;<br></code></pre></td></tr></table></figure><p>利用 tabular 实现标题与表格居中，内部的表格绘制由 tabularx 完成。</p><p>下面的图或许可以帮助你更好的理解上文<imgsrc="https://s3.uuu.ovh/imgs/2022/12/11/06318002edc10b2e.png" /></p><p>代码如下</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-comment">%%%%%% 错误示范 %%%%%%%</span><br><span class="hljs-keyword">\begin</span>&#123;tabularx&#125;&#123;0.8<span class="hljs-keyword">\textwidth</span>&#125; &#123;|c|c|c|&#125;<br>  <span class="hljs-keyword">\hline</span><br>  abc<span class="hljs-built_in">&amp;</span>edf <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>  <span class="hljs-keyword">\cline</span>&#123;2-3&#125;<br>  edf <span class="hljs-built_in">&amp;</span> abc <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>  <span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\end</span>&#123;tabularx&#125;<br><span class="hljs-comment">%%%%%%% 错误示范结束 %%%%%%%%</span><br><span class="hljs-keyword">\begin</span>&#123;table&#125;[!ht]<br>  <span class="hljs-keyword">\centering</span><br>  <span class="hljs-keyword">\caption</span>&#123;0.8 textwidth&#125;<span class="hljs-keyword">\label</span>&#123;tab:dummy-1&#125;<br>  &#123;<br>    <span class="hljs-keyword">\begin</span>&#123;tabularx&#125;&#123;0.8<span class="hljs-keyword">\textwidth</span>&#125; &#123;|X|X|X|&#125;<br>      <span class="hljs-keyword">\hline</span><br>      abc <span class="hljs-built_in">&amp;</span> edf <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>      <span class="hljs-keyword">\cline</span>&#123;2-3&#125;<br>      edf <span class="hljs-built_in">&amp;</span> abc <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>      <span class="hljs-keyword">\hline</span><br>    <span class="hljs-keyword">\end</span>&#123;tabularx&#125;<br>  &#125;<br><span class="hljs-keyword">\end</span>&#123;table&#125;<br><span class="hljs-comment">%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="hljs-keyword">\begin</span>&#123;table&#125;[!ht]<br>  <span class="hljs-keyword">\centering</span><br>  <span class="hljs-keyword">\caption</span>&#123;0.5 textwidth&#125;<span class="hljs-keyword">\label</span>&#123;tab:dummy-1&#125;<br>  &#123;<br>    <span class="hljs-keyword">\begin</span>&#123;tabularx&#125;&#123;0.5<span class="hljs-keyword">\textwidth</span>&#125; &#123;<br>        | &gt;&#123;<span class="hljs-keyword">\raggedright</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        | &gt;&#123;<span class="hljs-keyword">\centering</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        | &gt;&#123;<span class="hljs-keyword">\raggedleft</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        |&#125;<br>      <span class="hljs-keyword">\hline</span><br>      abc <span class="hljs-built_in">&amp;</span> edf <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>      <span class="hljs-keyword">\hline</span><br>      edf <span class="hljs-built_in">&amp;</span> abc <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>      <span class="hljs-keyword">\hline</span><br>    <span class="hljs-keyword">\end</span>&#123;tabularx&#125;<br>  &#125;<br><span class="hljs-keyword">\end</span>&#123;table&#125;<br><span class="hljs-comment">%%%%%%%%%%%%%%%%%%%%%</span><br><span class="hljs-keyword">\begin</span>&#123;table&#125;[!ht]<br>  <span class="hljs-keyword">\centering</span><br>  <span class="hljs-keyword">\caption</span>&#123;1 textwidth&#125;<span class="hljs-keyword">\label</span>&#123;tab:dummy-1&#125;<br>  &#123;<br>    <span class="hljs-keyword">\begin</span>&#123;tabularx&#125;&#123;<span class="hljs-keyword">\textwidth</span>&#125; &#123;<br>        | &gt;&#123;<span class="hljs-keyword">\raggedright</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        | &gt;&#123;<span class="hljs-keyword">\centering</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        | &gt;&#123;<span class="hljs-keyword">\raggedleft</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        |&#125;<br>      <span class="hljs-keyword">\hline</span><br>      abc <span class="hljs-built_in">&amp;</span> edf <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>      <span class="hljs-keyword">\hline</span><br>      edf <span class="hljs-built_in">&amp;</span> abc <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>      <span class="hljs-keyword">\hline</span><br>    <span class="hljs-keyword">\end</span>&#123;tabularx&#125;<br>  &#125;<br><span class="hljs-keyword">\end</span>&#123;table&#125;<br></code></pre></td></tr></table></figure><h2 id="高级技巧">高级技巧</h2><h3 id="x-列的不同宽度">X 列的不同宽度</h3><p>通常，单个表中的所有 X 列都设置为相同的宽度，但是可以让 tabularx将它们设置为不同的宽度。下面是文档中的例子。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&#123;<br>  &gt;&#123;\hsize<span class="hljs-operator">=</span>.<span class="hljs-number">5</span>\hsize\linewidth<span class="hljs-operator">=</span>\hsize&#125;X<br>  &gt;&#123;\hsize<span class="hljs-operator">=</span><span class="hljs-number">1.5</span>\hsize\linewidth<span class="hljs-operator">=</span>\hsize&#125;X<br>&#125; <br></code></pre></td></tr></table></figure><p>指定两列，第二列的宽度是第一列的三倍。但是，如果你想进行这种神奇地操作，则应遵循以下两条规则。</p><ul><li>确保所有 X列的宽度之和保持不变。（在上面的示例中，新宽度加起来仍然是默认宽度的两倍，即等于两个标准宽度相同X 列）</li><li>不要使用跨越任何 X 列的 </li></ul><h2 id="看看效果">看看效果</h2><p><imgsrc="https://s3.uuu.ovh/imgs/2022/12/11/ddef4fb8e67f2cac.png" /></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;table&#125;[]<br>  <span class="hljs-keyword">\centering</span><br>  <span class="hljs-keyword">\caption</span>&#123;测试&#125;<span class="hljs-keyword">\label</span>&#123;tab:dummy-1&#125;<br>  &#123;<br>    <span class="hljs-keyword">\begin</span>&#123;tabularx&#125;&#123;<span class="hljs-keyword">\textwidth</span>&#125; &#123;<br>        | &gt;&#123;<span class="hljs-keyword">\raggedright</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        | &gt;&#123;<span class="hljs-keyword">\centering</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        | &gt;&#123;<span class="hljs-keyword">\raggedleft</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        |&#125;<br>      <span class="hljs-keyword">\hline</span><br>      指企业在工商行政管理部门登记的注册资金。其中由三项原则：1. 资本确定原则：企业设立时，必须明确规定企业的资本总额和投资者认缴的数额2. 资本充实原则：资本金的筹集应及时、足额3. 资本维持原则：在持续经营期间应保持资本金的完整性，不得随意增加、减少资本 <span class="hljs-built_in">&amp;</span> edf <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>      <span class="hljs-keyword">\hline</span><br>      edf <span class="hljs-built_in">&amp;</span> abc <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>      <span class="hljs-keyword">\hline</span><br>    <span class="hljs-keyword">\end</span>&#123;tabularx&#125;<br>  &#125;<br><span class="hljs-keyword">\end</span>&#123;table&#125;<br></code></pre></td></tr></table></figure><h2 id="已知问题">已知问题</h2><p>tabularx在搜索最佳列宽时必须多次生成表格，因此速度要慢得多。此外，表格地多次膨胀可能会破坏某些TEX 结构。</p><h2 id="参考">参考</h2><ol type="1"><li>https://ctan.mirror.globo.tech/macros/latex/required/tools/tabularx.pdf</li><li>https://zhuanlan.zhihu.com/p/406538024</li><li>https://www.overleaf.com/learn/latex/Tables</li><li>https://latex.org/forum/viewtopic.php?t=5998</li><li>https://tex.stackexchange.com/questions/468363/when-should-the-tabularx-environment-be-used-or-not</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(Debian)-常见加固技巧（SSH）</title>
    <link href="/post/4828448e.html"/>
    <url>/post/4828448e.html</url>
    
    <content type="html"><![CDATA[<p>就在前几天，我朋友托管在我这的 TeamSpeak服务器突然无法访问了。简单分析后决定更新TeamSpeak，但在打包文件到本地整理的时候卡巴斯基突然报毒 <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs llvm">team.tar\team\.configrc\a\a<span class="hljs-comment">;检测到恶意对象</span><br>检测到<span class="hljs-comment">;team.tar\team\.configrc\a\</span><br>a文件<span class="hljs-comment">;活动用户</span><br>Trojan.Shell.Agent.<span class="hljs-keyword">br</span><span class="hljs-comment">;数据库;木马程序;高;确切</span><br>检测到<span class="hljs-comment">;2022/11/1 23:08</span><br></code></pre></td></tr></table></figure>突然意识到事情不对，检查 SSH 日志发现为 teamspeak单独建立的普通账户有一次远程登录。显然，服务器被黑了。详细检查后基本确定为<ahref="https://guanjia.qq.com/news/n1/2574.html">亡命徒（Outlaw）</a>的变种。因此在这记录SSH 常见的加固技巧。 <span id="more"></span></p><h2 id="ssh">SSH</h2><p>ssh 作为服务器必备组件，公网上各种自动化工具针对 22端口高强度扫描。而 ssh 的常见加固手段有： 1. 用高端口代替 22 端口 2.使用密钥认证代替密码登录 3. 使用密码也用高强度密码</p><h3 id="更改-ssh-端口开启密钥登录">更改 SSH 端口，开启密钥登录</h3><p>Debian 下 ssh 的配置文件分别是 /etc/ssh/sshd_config 和/etc/ssh/sshd_config.d/*.conf。其中 /etc/ssh/sshd_config为默认配置文件，不建议修改。我们自定义的文件位于 /etc/ssh/sshd_config.d/且以 .conf 结尾。 下面新建一个配置文件： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">touch</span> /etc/ssh/sshd_config.d/my.conf<br></code></pre></td></tr></table></figure></p><p>文件内容如下： <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Port</span> <span class="hljs-number">4309</span><br>PubkeyAuthentication <span class="hljs-literal">yes</span><br>PermitRootLogin <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure></p><p>Port 4309 表示 SSH 换用 4309 端口。PubkeyAuthentication yes表示开启密钥登录。PermitRootLogin yes 表示允许 root 登录，是否允许 root登录见仁见智。</p><p>更换端口后使用 -p 指定登录的端口，例如 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh root@192.168.43.2 -p 4309<br></code></pre></td></tr></table></figure></p><h3 id="生成密钥">生成密钥</h3><p>使用密钥登录需要生成密钥对，先在<strong>本地机器</strong>运行以下命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">&quot;your_email@example.com&quot;</span><br></code></pre></td></tr></table></figure></p><p>如果你的机器比较新，也可以使用 ed25519 算法，命令如下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t ed25519 -C <span class="hljs-string">&quot;your_email@example.com&quot;</span><br></code></pre></td></tr></table></figure></p><p>SSH 会询问你一些问题： 1. 密钥储存位置，默认为用户目录下的 .ssh 目录2.是否要为密钥添加密码，添加后每次使用要手动输入密码解锁密钥，如果不希望添加密码直接回车3. 确认密码，希望无密码继续回车</p><p>下面是运行过程 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">Generating public/private ed25519 key pair.<br>Enter file <span class="hljs-keyword">in</span> <span class="hljs-built_in">which</span> to save the key (C:\Users\king/.ssh/id_ed25519):<br>Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase):<br>Enter same passphrase again:<br>Your identification has been saved <span class="hljs-keyword">in</span> C:\Users\king/.ssh/id_ed25519.<br>Your public key has been saved <span class="hljs-keyword">in</span> C:\Users\king/.ssh/id_ed25519.pub.<br>The key fingerprint is:<br>SHA256:zuN/3FgL12mtKYA3+deN4KA8UZmD7QrZSqouZv5HWDc your_email@example.com<br>The key<span class="hljs-string">&#x27;s randomart image is:</span><br><span class="hljs-string">+--[ED25519 256]--+</span><br><span class="hljs-string">|                 |</span><br><span class="hljs-string">|                 |</span><br><span class="hljs-string">|         o o     |</span><br><span class="hljs-string">|     . E. *      |</span><br><span class="hljs-string">|    o .oS+ o   .o|</span><br><span class="hljs-string">|   . .+o+ B o ooo|</span><br><span class="hljs-string">|    .o ++= B B.*.|</span><br><span class="hljs-string">|.o  ....=.  B B o|</span><br><span class="hljs-string">|+++o.   .o.. o   |</span><br><span class="hljs-string">+----[SHA256]-----+</span><br></code></pre></td></tr></table></figure></p><p>完成后于用户的 .ssh 目录下生成以算法命名的两文件，本例中为 id_ed25519和 id_ed25519.pub。其中 id_ed25519为私钥，请妥善保管，不要泄露；id_ed25519.pub为公钥，准备上传至服务器。俩文件其实就是文本，用文本编辑器可以直接查看内容。下面是我刚刚生成的公钥内容<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">ssh-ed<span class="hljs-number">25519</span> AAAAC<span class="hljs-number">3</span><span class="hljs-symbol">NzaC1</span>lZDI<span class="hljs-number">1</span><span class="hljs-symbol">NTE5</span>AAAAI<span class="hljs-symbol">NnKAEj8</span>kC<span class="hljs-number">3</span>Uw<span class="hljs-number">5</span>tizK<span class="hljs-number">5</span>zg<span class="hljs-symbol">nPmQefx8</span>XWPVBECHxsx<span class="hljs-number">4</span>LhT your_email@example.com<br></code></pre></td></tr></table></figure></p><h3 id="上传密钥">上传密钥</h3><p>SSH 要求将公钥保存在每个用户的 ~/.ssh/authorized_keys中。比如准备将生成的密钥用以登录 test 用户，即将公钥内容粘贴进 test 的~/.ssh/authorized_keys 文件中即可。没有 authorized_keys 就手动创建。</p><p>注意，authorized_keys文件的权限要设为644，即只有文件所有者才能写。如果权限设置不对，SSH服务器可能会<strong>拒绝</strong>读取该文件。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 644 ~/.ssh/authorized_keys<br></code></pre></td></tr></table></figure></p><p>完成后重启 sshd 服务 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart sshd<br></code></pre></td></tr></table></figure></p><p>登录服务器，应该会自动登录。也可以查看日志 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/log/auth.log | grep <span class="hljs-string">&#x27;Accepted&#x27;</span><br></code></pre></td></tr></table></figure></p><p>应该出现类似内容 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Nov</span>  <span class="hljs-number">3</span> <span class="hljs-number">15</span>:<span class="hljs-number">35</span>:<span class="hljs-number">45</span> iZeio043iZ sshd[<span class="hljs-number">7356</span>]: Accepted publickey for test from <span class="hljs-number">193.104.113.211</span> port <span class="hljs-number">56834</span> ssh2: RSA SHA256:eg5UsdfmWUDimck1ozg+KDoMwIZbwMtejUHILTyg<br></code></pre></td></tr></table></figure></p><h3 id="禁用密码登录">禁用密码登录</h3><p>如果成功使用密钥登录了，下面可以禁用密码登录以提高安全性。编辑上文创建的/etc/ssh/sshd_config.d/my.conf 文件，添加一行 <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">PasswordAuthentication</span> <span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure></p><p>即可禁用密码登录。 ## Fail2Ban</p><blockquote><p>Fail2Ban是一个入侵检测系统框架，它可以保护电脑服务器免受蛮力攻击。以Python程序设计语言编写，并能够在类Unix系统上运行，这些系统具有本地安装的数据包控制系统或防火墙的接口，例如Iptables或TCPWrapper。 ——维基百科</p></blockquote><p>Fail2Ban 通过检查日志确定黑名单，通过 Iptables 进行禁封一定时间。</p><h3 id="安装与准备">安装与准备</h3><p>首先是最简单的安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br>sudo apt install fail2ban<br></code></pre></td></tr></table></figure><p>安装完成后检查是否启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl status fail2ban<br></code></pre></td></tr></table></figure><p>正常运行结果如下</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dts">● fail2ban.service - Fail2Ban Service<br><span class="hljs-symbol">     Loaded:</span> loaded (<span class="hljs-keyword">/lib/</span>systemd<span class="hljs-keyword">/system/</span>fail2ban.<span class="hljs-attr">service</span><span class="hljs-punctuation">;</span> <span class="hljs-attr">enabled</span><span class="hljs-punctuation">;</span> vendor preset: enabled)<br><span class="hljs-symbol">     Active:</span> active (running) since Wed <span class="hljs-number">2022</span><span class="hljs-number">-11</span><span class="hljs-number">-02</span> <span class="hljs-number">00</span>:<span class="hljs-number">26</span>:<span class="hljs-number">47</span> CST<span class="hljs-punctuation">;</span> <span class="hljs-number">1</span> day <span class="hljs-number">11</span>h ago<br><span class="hljs-symbol">       Docs:</span> man:fail2ban(<span class="hljs-number">1</span>)<br><span class="hljs-symbol">    Process:</span> <span class="hljs-number">10748</span> ExecStartP<span class="hljs-attr">re</span><span class="hljs-operator">=</span><span class="hljs-keyword">/bin/</span>mkdir -p <span class="hljs-keyword">/run/</span>fail2ban (<span class="hljs-attr">code</span><span class="hljs-operator">=</span>exited, <span class="hljs-attr">status</span><span class="hljs-operator">=</span><span class="hljs-number">0</span>/SUCCESS)<br>   Main PID: <span class="hljs-number">10749</span> (fail2ban-server)<br><span class="hljs-symbol">      Tasks:</span> <span class="hljs-number">5</span> (limit: <span class="hljs-number">2335</span>)<br><span class="hljs-symbol">     Memory:</span> <span class="hljs-number">15.5</span>M<br><span class="hljs-symbol">        CPU:</span> <span class="hljs-number">36.352</span>s<br><span class="hljs-symbol">     CGroup:</span> /system.slice/fail2ban.service<br>             └─<span class="hljs-number">10749</span> <span class="hljs-keyword">/usr/</span>bin/python3 <span class="hljs-keyword">/usr/</span>bin/fail2ban-server -xf start<br><br>Nov <span class="hljs-number">02</span> <span class="hljs-number">00</span>:<span class="hljs-number">26</span>:<span class="hljs-number">47</span> VM<span class="hljs-number">-20</span><span class="hljs-number">-6</span>-debian systemd[<span class="hljs-number">1</span>]: Starting Fail2Ban Service...<br>Nov <span class="hljs-number">02</span> <span class="hljs-number">00</span>:<span class="hljs-number">26</span>:<span class="hljs-number">47</span> VM<span class="hljs-number">-20</span><span class="hljs-number">-6</span>-debian systemd[<span class="hljs-number">1</span>]: Started Fail2Ban Service.<br>Nov <span class="hljs-number">02</span> <span class="hljs-number">00</span>:<span class="hljs-number">26</span>:<span class="hljs-number">47</span> VM<span class="hljs-number">-20</span><span class="hljs-number">-6</span>-debian fail2ban-server[<span class="hljs-number">10749</span>]: Server ready<br></code></pre></td></tr></table></figure><p>Fail2ban 在安装时会创建两个默认的配置文件/etc/fail2ban/jail.d/defaults-debian.conf 和 /etc/fail2ban/jail.conf。我不建议直接修改这些文件，因为更新 Fail2ban 时它们可能会被覆盖。</p><p>Fail2ban 将按以下顺序读取配置文件。每个 .local 文件都会覆盖 .conf文件中的设置： 1. /etc/fail2ban/jail.conf 2./etc/fail2ban/jail.d/<em>.conf 3. /etc/fail2ban/jail.local 4./etc/fail2ban/jail.d/</em>.local</p><p>因此我们直接将默认配置复制到 /etc/fail2ban/jail.d/ 然后进行修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cp</span> /etc/fail2ban/jail.&#123;conf,<span class="hljs-built_in">local</span>&#125;<br>sudo vim /etc/fail2ban/jail.local<br></code></pre></td></tr></table></figure><h3 id="配置">配置</h3><h4 id="白名单">白名单</h4><p>首先是白名单配置，白名单里的 ip 永远不会被禁封。如果你有其他固定 ip可以添加进来，没有也可以直接跳过这个步骤。 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ignoreip</span> = <span class="hljs-number">127.0.0.1</span>/<span class="hljs-number">8</span> ::<span class="hljs-number">1</span> <span class="hljs-number">192.168.1.0</span>/<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure></p><h4 id="禁封条件与时间">禁封条件与时间</h4><p>bantime，findtime 和 maxretry设置了禁止时间和禁止条件。bantime是禁止持续的时间。如果未指定后缀则默认为秒，要永久禁止IP，请使用负数。findtime是设置失败次数之间的持续时间。例如，如果将 Fail2ban设置为在尝试五次失败后禁止IP，则这些失败必须在 findtime时间内发生。maxretry是IP失败尝试次数。默认值设置为5。下面是设置为10分钟完成5次失败，禁封 1天。 <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">bantime</span>  <span class="hljs-operator">=</span> <span class="hljs-number">1</span>d<br><span class="hljs-attribute">findtime</span>  <span class="hljs-operator">=</span> <span class="hljs-number">10</span>m<br><span class="hljs-attribute">maxretry</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></p><p>Jail 描述如何检测服务的条件。其中服务是系统的任意服务，比如 sshd服务。条件是包括过滤器和操作。计算符合搜索模式的日志记录，并在满足预定条件时执行相应的操作。</p><p>Fail2ban 附带许多 Jail作为示例，系统每一项服务都可以找到对应Jail配置。我们还可以创建自己的Jail 配置。默认情况下，在CentOS 8上没有启用Jail。要启用Jail，您需要在添加 enabled =true。以下示例显示了如何为sshd服务启用Jail。 <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[sshd]</span><br><span class="hljs-attr">enabled</span>   = <span class="hljs-literal">true</span><br><span class="hljs-attr">port</span>    = <span class="hljs-number">4309</span><br><span class="hljs-attr">logpath</span> = %(sshd_log)s<br><span class="hljs-attr">backend</span> = %(sshd_backend)s<br></code></pre></td></tr></table></figure></p><p>因为上文中将 ssh 的登录端口改为 4309，因此这里的端口同样修改为 4309。重启 Fail2Ban 使配置生效。</p><h2 id="参考">参考</h2><ol type="1"><li>https://wangdoc.com/ssh/key</li><li>https://www.myfreax.com/install-configure-fail2ban-on-ubuntu-20-04/</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>折腾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Adguard Home 设置</title>
    <link href="/post/ce8e32b9.html"/>
    <url>/post/ce8e32b9.html</url>
    
    <content type="html"><![CDATA[<p>Adguard Home 是 Windows 下最好的 DNS 管理器！会看见这篇文章，想必你对Adguard Home 的功能已经有所了解，但我要泼一盆冷水， Adguard Home的广告过滤功能比较鸡肋，效果不如浏览器的 uBlock Origin插件好。但如果将其当作一个 DNS 管理器，它将十分优秀。本文主要介绍如何将Adguard Home 部署在 Windows 下并为本机提供 DNS 服务。</p><span id="more"></span><p>在官方<ahref="https://github.com/AdguardTeam/AdGuardHome/releases">Github仓库</a>中选择适合 Windows 的版本，或者点击这下载<ahref="https://github.com/AdguardTeam/AdGuardHome/releases/download/v0.107.13/AdGuardHome_windows_amd64.zip">AdGuardHome_windows_amd64.zip(v0.107)</a>。解压至一个好找的地方(别放在桌面，设置完后一不小心删了会无法联网)</p><p>文件如下：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">Mode                 LastWriteTime         Length Name</span><br><span class="hljs-literal">----</span>                 <span class="hljs-literal">-------------</span>         <span class="hljs-literal">------</span> <span class="hljs-literal">----</span><br><span class="hljs-literal">-----</span>           <span class="hljs-comment">2022/9/14    22:46       33306112 AdGuardHome</span><span class="hljs-string">.</span><span class="hljs-comment">exe</span><br><span class="hljs-literal">-----</span>           <span class="hljs-comment">2022/9/14    22:46            587 AdGuardHome</span><span class="hljs-string">.</span><span class="hljs-comment">exe</span><span class="hljs-string">.</span><span class="hljs-comment">sig</span><br><span class="hljs-literal">-----</span>           <span class="hljs-comment">2022/9/14    22:46          51429 CHANGELOG</span><span class="hljs-string">.</span><span class="hljs-comment">md</span><br><span class="hljs-literal">-----</span>           <span class="hljs-comment">2022/9/14    22:46          35149 LICENSE</span><span class="hljs-string">.</span><span class="hljs-comment">txt</span><br><span class="hljs-literal">-----</span>           <span class="hljs-comment">2022/9/14    22:46          23266 README</span><span class="hljs-string">.</span><span class="hljs-comment">md</span><br></code></pre></td></tr></table></figure><p>首次运行需要以管理员身份运行AdGuardHome.exe，等命令行跑完。直到出现类似下面的命令</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">info</span>] Service control action: install<br>[<span class="hljs-keyword">info</span>] Service has been started<br>[<span class="hljs-keyword">info</span>] Almost ready!<br>AdGuard Home <span class="hljs-keyword">is</span> successfully installed <span class="hljs-keyword">and</span> will automatically <span class="hljs-keyword">start</span> <span class="hljs-keyword">on</span> boot ．<br>There are a few more things that must be configured <span class="hljs-keyword">before</span> you can use it.<br>lick <span class="hljs-keyword">on</span> the link below <span class="hljs-keyword">and</span> follow the Installation Wizard steps finish setup.<br>[<span class="hljs-keyword">info</span>] AdGuard Home <span class="hljs-keyword">is</span> available <span class="hljs-keyword">on</span> the f0110 丽 ng addresses ：<br>[<span class="hljs-keyword">info</span>] GO <span class="hljs-keyword">to</span> http://<span class="hljs-number">192.168</span><span class="hljs-number">.11</span>:<span class="hljs-number">3000</span><br>[<span class="hljs-keyword">info</span>] Go <span class="hljs-keyword">to</span> http://[::<span class="hljs-number">1</span>]:<span class="hljs-number">3000</span><br>[<span class="hljs-keyword">info</span>] Go <span class="hljs-keyword">to</span> http://<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">3000</span><br>[<span class="hljs-keyword">info</span>] Action install has been done successfully <span class="hljs-keyword">on</span> windows-service<br></code></pre></td></tr></table></figure><h2 id="adguard-home-设置">Adguard Home 设置</h2><p>在浏览器中输入 http://127.0.0.1:3000 即可进入 Adguard Home的管理页面，首先设置账号和密码，一路下一步即可，然后进入“DNS 设置”。</p><p><imgsrc="https://s3.bmp.ovh/imgs/2022/09/29/eea15e9eae345f58.png" /></p><p>在上游DNS服务器中填入以下内容，即可设置阿里DNS与腾讯DNS为上游 DoH解析，同时 DoH 的 DNS 可以有效防止运营商的 DNS 污染。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//dns.alidns.com/dns-query</span><br><span class="hljs-symbol">https:</span><span class="hljs-comment">//doh.pub/dns-query</span><br></code></pre></td></tr></table></figure><p>在 Bootstrap DNS 中填入，使用阿里DNS和GoogleDNS作为 DoH 服务器解析DNS。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">223</span>.<span class="hljs-number">5</span>.<span class="hljs-number">5</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">8</span>.<span class="hljs-number">8</span>.<span class="hljs-number">8</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">2001</span>:<span class="hljs-number">4860</span>:<span class="hljs-number">4860</span>::<span class="hljs-number">8888</span><br><span class="hljs-attribute">2400</span>:<span class="hljs-number">3200</span>::<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://s3.bmp.ovh/imgs/2022/09/29/5f98fdce140013c7.png" /></p><p>同时强烈推荐你丢弃 IPv6 解析，目前许多老小区的网络设施无法使用IPv6，防止 Windows 使用 IPv6 去访问目标服务器。</p><p><imgsrc="https://s3.bmp.ovh/imgs/2022/09/29/1328ec16d4029d8b.png" /></p><p>其余默认即可。</p><p>DNS 过滤名单如下添加即可，太多不但拖慢速度而且效果不明显。</p><p><imgsrc="https://s3.bmp.ovh/imgs/2022/09/29/a56ff7dec97a56e1.png" /></p><h2 id="windows-设置">Windows 设置</h2><p>Adguard Home 的自带的设置指导已经十分详细。对于 Windows步骤如下。</p><ol type="1"><li>通过开始菜单或 Windows 搜索功能打开控制面板。</li><li>点击进入「网络和 Internet」后，再次点击进入「网络和共享中心」</li><li>在窗口的左侧点击「更改适配器设置」。</li><li>选择您正在连接的网络设备，右击它并选择「属性”」。</li><li>在列表中找到「Internet 协议版本 4(TCP/IPv4)」，选择并再次点击「属性」。</li><li>选择「使用下面的 DNS 服务器地址」，并输入您的 AdGuard Home服务器地址（127.0.0.1）。</li></ol><p><imgsrc="https://s3.bmp.ovh/imgs/2022/09/29/a4391d4dc0860f91.png" /></p><h3 id="开机自启">开机自启</h3><p>在计划任务中新建任务，按下图填入（用户名要填你自己电脑登陆的用户名！！）<img src="https://s3.bmp.ovh/imgs/2022/09/29/80bee65439cc057c.png" /><img src="https://s3.bmp.ovh/imgs/2022/09/29/3d2771b4a2d150b1.png" />程序就选择 Adguard Home.exe <imgsrc="https://s3.bmp.ovh/imgs/2022/09/29/e70fb333adcf0d0e.png" /> <imgsrc="https://s3.bmp.ovh/imgs/2022/09/29/42c16ecf60c06269.png" /> <imgsrc="https://s3.bmp.ovh/imgs/2022/09/29/08dddfddb7e47d96.png" /></p><p>完成</p>]]></content>
    
    
    
    <tags>
      
      <tag>折腾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现分配固定大小内存池-C++</title>
    <link href="/post/e678ff2a.html"/>
    <url>/post/e678ff2a.html</url>
    
    <content type="html"><![CDATA[<h2 id="内存池简述">内存池简述</h2><blockquote><p>内存池（Memory Pool），又被称为固定大小区块规划（fixed-size-blocksallocation），允许程序员以类似 C语言 的 malloc 或是 C++ 的 new操作数进行动态的存储器规划。对于其它动态存储器规划的实践来说，因为会变动存储器区块大小导致的碎片问题，导致在实时系统上受限于性能因此，根本无法使用。内存池提供了一个更有效率的解决方案：预先规划一定数量的存储器区块，使得整个程序可以在执行期规划(allocate)、使用 (access)、归还 (free) 存储器区块。 ——维基百科</p></blockquote><span id="more"></span><h2 id="实现设计">实现设计</h2><p>编写一个<code>MyMemoryPool</code>类作为内存池，<code>MyMemoryPool</code>类参照C++ 标准库中的 <ahref="https://zh.cppreference.com/w/cpp/memory/allocator">std::allocator</a>设计。核心是维护两条链表：内存块表(open_list)、分配后被释放而产生的重分配链表 (free_memory)。</p><p>内存块表设计如图</p><figure><img src="https://s3.bmp.ovh/imgs/2022/09/26/cce4cd26feb2dd5f.png"alt="内存块表" /><figcaption aria-hidden="true">内存块表</figcaption></figure><p>一次性申请一大块内存，然后在头部开辟表头，用以储存之前的内存头地址。剩余部分划分为多个固定大小的区块，将成为真正的内存分配区域。</p><p>重分配链表 (free_memory) 构成如图</p><figure><img src="https://s3.bmp.ovh/imgs/2022/09/26/12d0fab63da20fda.png"alt="重分配链表" /><figcaption aria-hidden="true">重分配链表</figcaption></figure><p>重分配链表不含表头区域，完全是由待分配的内存构成。</p><p>内存分配步骤为： 1. 检查重分配链表 (free_memory) 是否有内存 2.若有直接分配重分配链表的内存，若无准备分配内存块表的内存 3.检查内存块表的空闲空间是否足够分配所需内存 4.若空闲空间不足，申请新的内存块表；否则直接分配内存块表的内存</p><h2 id="具体实现">具体实现</h2><h3 id="基础建设">基础建设</h3><p>根据 <ahref="https://zh.cppreference.com/w/cpp/memory/allocator">allocator</a>的要求，我的目标是完成 C++11 的部分标准且我的类名为<code>MyMemoryPool</code>。因此首先实现几个别名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> value_type = T;<br><span class="hljs-keyword">using</span> potinter = T *;<br><span class="hljs-keyword">using</span> const_pointer = <span class="hljs-type">const</span> T *;<br><span class="hljs-keyword">using</span> reference = T &amp;;<br><span class="hljs-keyword">using</span> const_reference = <span class="hljs-type">const</span> T &amp;;<br><span class="hljs-keyword">using</span> size_type = <span class="hljs-type">size_t</span>;<br></code></pre></td></tr></table></figure><p>由于标准没有对构造函数进行具体要求，我直接使用默认构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">MyMemoryPool</span>() &#123;&#125;<br><span class="hljs-built_in">MyMemoryPool</span>(<span class="hljs-type">const</span> MyMemoryPool &amp;other) &#123;&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-built_in">MyMemoryPool</span>(<span class="hljs-type">const</span> MyMemoryPool&lt;U&gt; &amp;other) &#123;&#125;<br></code></pre></td></tr></table></figure><p>rebind 是为了应对类似 std::list的容器，这类容器在往往要求分配的是一个结构而不是储存的类型，比如<code>std::list&lt;int,std::allocator&lt;int&gt;&gt;</code> 会在内部将<code>std::allocator&lt;int&gt;</code> 改为<code>std::allocator&lt;node&lt;int&gt;&gt;</code> 而 node 对调用 list的人是不可见的，因此 <code>allocator</code> 需要提供 <code>rebind</code>使 list 能自行更改指定的分配器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rebind</span> &#123; <span class="hljs-keyword">typedef</span> MyMemoryPool&lt;U&gt; other; &#125;;<br></code></pre></td></tr></table></figure><p>下面将是 private部分，即我自己的实现细节。首先为方便理解变量的具体含义，定义几个类型别名、结构、指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> block_size = <span class="hljs-number">1024lu</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>  T *data;<br>  Node *next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> Node *block_pointer;<br><span class="hljs-keyword">typedef</span> Node *memory_pointer;<br><span class="hljs-keyword">typedef</span> T *data_pointer;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> *byte_pointer;<br>block_pointer open_list;<br>memory_pointer current;<br>memory_pointer free_memory;<br>memory_pointer end;<br></code></pre></td></tr></table></figure><p><code>block_size</code>是每次申请的内存块大小，<code>Node</code>用于充当内存块头和空闲内存分配区，<code>block_pointer</code>指向当前正在分配的内存块头，<code>current</code>指向即将分配的空闲内存块，<code>free_memory</code>是释放后产生的空闲内存，<code>end</code>为当前内存块表的最后一个内存地址</p><h3 id="分配器">分配器</h3><p>根据 <ahref="https://zh.cppreference.com/w/cpp/memory/allocator/allocate">成员函数allocate</a> 的要求，我原本应该实现一个可以一次分配多个内存块且根据 hint指针进行调整的分配器，但为简化实现，我的分配器每次只分配一个内存区块且忽略hint 指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">data_pointer <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, <span class="hljs-type">const</span> data_pointer hint = <span class="hljs-literal">nullptr</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (free_memory != <span class="hljs-literal">nullptr</span>) &#123;<br>    memory_pointer target = free_memory;<br>    free_memory = free_memory-&gt;next;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;data_pointer&gt;(target);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (current &gt;= end)<br>    <span class="hljs-built_in">new_block</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;data_pointer&gt;(current++);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先判断是否有释放后产生的空闲内存，有优先使用它，否则分配内存块表中的空闲内存。检查内存块表是否有剩余空间，若无申请新的内存块表，最后将指向空闲内存的<code>current</code>强制转换为数据指针后返回（后自增）。</p><h3 id="申请新的内存块表">申请新的内存块表</h3><p>调用<code>operator new</code>从系统中获得一块固定大小的内存。由于<code>char</code>占用1 字节，因此<code>char*</code>即指向 char类型的指针是一字节一字节的操作，将其当作直接操作内存字节的指针而不是真的需要操作字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">padPointer</span><span class="hljs-params">(byte_pointer p, <span class="hljs-type">size_t</span> align)</span> <span class="hljs-type">const</span> </span>&#123;<br> <span class="hljs-type">uintptr_t</span> result = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(p);<br> <span class="hljs-keyword">return</span> ((align - result) % align);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">new_block</span><span class="hljs-params">()</span> </span>&#123;<br> byte_pointer target = <span class="hljs-built_in">static_cast</span>&lt;byte_pointer&gt;(::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(block_size));<br> <span class="hljs-built_in">reinterpret_cast</span>&lt;block_pointer&gt;(target)-&gt;next = open_list;<br> open_list = <span class="hljs-built_in">reinterpret_cast</span>&lt;block_pointer&gt;(target);<br> byte_pointer body = target + <span class="hljs-built_in">sizeof</span>(block_pointer);<br> <span class="hljs-type">size_t</span> bodyPadding = <span class="hljs-built_in">padPointer</span>(body, <span class="hljs-built_in">alignof</span>(Node));<br> current = <span class="hljs-built_in">reinterpret_cast</span>&lt;memory_pointer&gt;(body + bodyPadding);<br> end = <span class="hljs-built_in">reinterpret_cast</span>&lt;memory_pointer&gt;(target + block_size -<span class="hljs-built_in">sizeof</span>(Node) + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>target</code>指向新申请的连续空闲内存，同时在头部生成一个Node结构充当内存块头，并将next 指向旧内存块。<code>body</code>指向内存块头 (Node)的末尾，padPointer 函数的存在是因为“内存对齐”的要求。</p><p>内存对齐是一个基础却复杂的概念，简单来说“数据项仅仅能存储在地址是数据项大小的整数倍的内存位置上”。alignof能够返回查询类型的对齐要求，padPointer 则返回 p与对齐地址的距离。也许你更常看见</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(x) + <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(<span class="hljs-number">7u</span>)) &amp; ~<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(<span class="hljs-number">7u</span>);<br></code></pre></td></tr></table></figure><p>即返回将 <code>x</code> 转化为 <code>unsigned long int</code> 后的 8的倍数。这也是进行内存对齐。</p><h3 id="释放元素">释放元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(data_pointer p, <span class="hljs-type">size_t</span> n = <span class="hljs-number">1</span>)</span> </span>&#123;<br> <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">nullptr</span>) &#123;<br>   <span class="hljs-built_in">reinterpret_cast</span>&lt;memory_pointer&gt;(p)-&gt;next = free_memory;<br>   free_memory = <span class="hljs-built_in">reinterpret_cast</span>&lt;memory_pointer&gt;(p);<br> &#125;<br></code></pre></td></tr></table></figure><p>将 p 加入 free_memory 并忽略参数 n。</p><h2 id="完整实现">完整实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MY_MEMORYPOOL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MY_MEMORYPOOL</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMemoryPool</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> block_size = <span class="hljs-number">1024lu</span>;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    T *data;<br>    Node *next;<br>  &#125;;<br>  <span class="hljs-keyword">typedef</span> Node *block_pointer;<br>  <span class="hljs-keyword">typedef</span> Node *memory_pointer;<br>  <span class="hljs-keyword">typedef</span> T *data_pointer;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> *byte_pointer;<br>  block_pointer open_list;<br>  memory_pointer current;<br>  memory_pointer free_memory;<br>  memory_pointer end;<br><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">padPointer</span><span class="hljs-params">(byte_pointer p, <span class="hljs-type">size_t</span> align)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-type">uintptr_t</span> result = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(p);<br>    <span class="hljs-keyword">return</span> ((align - result) % align);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">new_block</span><span class="hljs-params">()</span> </span>&#123;<br>    byte_pointer target = <span class="hljs-built_in">static_cast</span>&lt;byte_pointer&gt;(::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(block_size));<br>    <span class="hljs-built_in">reinterpret_cast</span>&lt;block_pointer&gt;(target)-&gt;next = open_list;<br>    open_list = <span class="hljs-built_in">reinterpret_cast</span>&lt;block_pointer&gt;(target);<br>    byte_pointer body = target + <span class="hljs-built_in">sizeof</span>(block_pointer);<br>    <span class="hljs-type">size_t</span> bodyPadding = <span class="hljs-built_in">padPointer</span>(body, <span class="hljs-built_in">alignof</span>(Node));<br>    current = <span class="hljs-built_in">reinterpret_cast</span>&lt;memory_pointer&gt;(body + bodyPadding);<br>    end = <span class="hljs-built_in">reinterpret_cast</span>&lt;memory_pointer&gt;(target + block_size -<br>                                           <span class="hljs-built_in">sizeof</span>(Node) + <span class="hljs-number">1</span>);<br>  &#125;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">MyMemoryPool</span>()<br>      : <span class="hljs-built_in">open_list</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">current</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">free_memory</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">end</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>  <span class="hljs-function">data_pointer <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, <span class="hljs-type">const</span> data_pointer hint = <span class="hljs-literal">nullptr</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (free_memory != <span class="hljs-literal">nullptr</span>) &#123;<br>      memory_pointer target = free_memory;<br>      free_memory = free_memory-&gt;next;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;data_pointer&gt;(target);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (current &gt;= end)<br>      <span class="hljs-built_in">new_block</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;data_pointer&gt;(current++);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(data_pointer p, <span class="hljs-type">size_t</span> n = <span class="hljs-number">1</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;memory_pointer&gt;(p)-&gt;next = free_memory;<br>      free_memory = <span class="hljs-built_in">reinterpret_cast</span>&lt;memory_pointer&gt;(p);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rebind</span> &#123; <span class="hljs-keyword">typedef</span> MyMemoryPool&lt;U&gt; other; &#125;;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="参考">参考</h2><ol type="1"><li>https://github.com/cacay/MemoryPool</li><li>https://zhuanlan.zhihu.com/p/280706845</li><li>https://www.cnblogs.com/wgwyanfs/p/6733609.html</li><li>https://zh.cppreference.com/w/cpp/language/alignof</li><li>https://en.cppreference.com/w/cpp/memory/allocator</li><li>https://stackoverflow.com/questions/1845482/what-is-uintptr-t-data-type</li><li>https://www.zhihu.com/question/25527491/answer/56571062</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划-入门（记忆搜索与逆序递推）</title>
    <link href="/post/48595c53.html"/>
    <url>/post/48595c53.html</url>
    
    <content type="html"><![CDATA[<p>本篇博文旨在进行动态规划的入门，介绍基础思想。动态规划是十分基础的思想，但其依旧有一定的难度，特别是对于像我这种非计算机专业且无竞赛经验的爱好者。<span id="more"></span> ## 动态规划简介动态规划本身并无实际意义，它更像一种思想与手段以解决问题。如果一个问题可以被分解为若干子问题，且子问题又可解决主问题，我应该考虑动态规划。</p><p>动态规划有四个关键： 1. 状态 2. 状态转移 3. 最优子结构 4.重叠子问题</p><h2 id="引子">引子</h2><p>我们以力扣上最简单的动态规划为例（<ahref="https://leetcode.cn/problems/climbing-stairs/">70.爬楼梯</a>）。</p><blockquote><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2个台阶。你有多少种不同的方法可以爬到楼顶呢？</p></blockquote><p>输入：n = 2<br />输出：2<br />解释：有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶</p><p>我先不考虑动态规划，以最简单朴素的思想去思考。我可以构建一个二叉树，左右子节点分别代表爬1 或 2 个台阶。我以爬 4 阶为例，二叉树如图。 <imgsrc="https://s3.bmp.ovh/imgs/2022/09/02/eee24b9043e8d849.png"alt="二叉树" /></p><p>如果了解回溯法，马上反应过来这种二叉树可以使用回溯法生成。实际上回溯法确实和动态规划有些交际，就我目前观察，只要求判断对错、输出个数常见动态规划；要求输出过程的只能回溯法生成了。</p><p>就算你不知道回溯法，相信你也能看出这幅图有很多地方是重复的。比如 1节点的左子树不就是 2节点的子树吗？相似的地方还有很多，这就是<code>重叠子问题</code>。在遍历时有大量的计算是重复的，动态规划实际上就是要解决<code>重叠子问题</code>。</p><p>为了解决重叠子问题，一般有两类： 1. 记忆化搜索 2. 逆向递推</p><h2 id="记忆化搜索">记忆化搜索</h2><p>记忆化搜索很简单，比如你先生成 1 节点的子树，然后去看看 1 的左子树 2节点，然后先去 3 节点之后又去 4 节点。完成 1节点的子树后，你实际上已经生成过一遍 2,3,4节点的子树了，记下来，下次要查看 2,3,4节点就直接调用记录即可，不用重新生成。</p><p>那么，如何根据已经储存的节点数据得到新的节点数据呢？这就是<code>状态</code>和<code>状态转移方程</code>的工作。</p><p>我设 node(x) 表示 x 台阶到 n 台阶的不同方法总数，即题目所求为node(1)。这就是<code>状态</code>。</p><p>1 台阶能到达 2,3 台阶，因此它的状态为 2,3 状态相加。有node(1)=node(2)+node(3)，我将其扩展到一般状态node(x)=node(x+1)+node(x+2)，这就是<code>状态转移方程</code>。</p><p>现在我完成了动态规划的所有问题，就剩编码实现了。一个简单 C++的实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> node[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">memset</span>(node,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(node));<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(i&gt;=n) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(node[i]&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> node[i];<br>  <span class="hljs-keyword">return</span> node[i]+=<span class="hljs-built_in">dp</span>(i+<span class="hljs-number">1</span>)+<span class="hljs-built_in">dp</span>(i+<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>一行一行看，<code>int node[100]</code>定义了一个足够大的数组用以储存每一个节点的状态，node[1]就是 1 台阶状态...</p><p><code>memset(node,0,sizeof(node))</code> 将 node 数组全部初始化为 0，这便是动态规划的初始化。</p><p><code>int n</code>储存目标台阶数。</p><p><code>dp</code>函数是动态规划的关键，<code>if(i&gt;=n) return 1</code>判断当前试图计算的台阶是否已经超过目标，即动态规划的边界条件。</p><p><code>if(node[i]&gt;0) return node[i]</code>如果希望计算的台阶状态已经计算过了，直接返回结果，实现<code>记忆化</code>。</p><p><code>return node[i]+=dp(i+1)+dp(i+2)</code>先根据状态转移方程计算当前台阶状态，这里利用了c++ 赋值语句本身返回结果的特性少写了一行代码。</p><h2 id="逆序递推">逆序递推</h2><p>记忆化搜索虽能解决问题，但不停递归比较慢，逆序搜索可以使用循环解决问题。</p><p>经过上面的分析，我的目标是解决递推时出现的大量重复计算。观察状态转移方程<code>node(x)=node(x+1)+node(x+2)</code>和二叉树，可以发现要计算一个节点就必须先求下一个节点，如果我直接从后往前计算，我也能防止重复计算。</p><p>下面是一个简单的 c++ 实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>  <span class="hljs-type">int</span> node[n+<span class="hljs-number">1</span>];<br>  <span class="hljs-built_in">memset</span>(node,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(node));<br>  node[n]=<span class="hljs-number">1</span>;<br>  node[n<span class="hljs-number">-1</span>]=<span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>    node[i]=node[i+<span class="hljs-number">1</span>]+node[i+<span class="hljs-number">2</span>];<br>  &#125;<br>  <span class="hljs-keyword">return</span> node[<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>依旧一行一行看，<code>int n</code>储存目标台阶数。</p><p><code>int node[n+1]</code>定义了一个数组用以储存每一个节点的状态，这里使用了C 语言的可选功能可变数组，因此 g++ 和 clang++ 可以编译通过但 msvc不行（力扣使用 clang++因此可以通过）。可以改为<code>int node[100]</code>以符合标准 C++。</p><p><code>memset(node,0,sizeof(node))</code> 将 node 数组全部初始化为 0。 <code>node[n]=1</code> 与 <code>node[n-1]=2</code>分别表示最后一个台阶的状态为 1，倒数第二个台阶状态为2。这三条代码完成了动态规划的初始化。</p><p>一个从后往前的循环，利用<code>状态转移方程</code>完美的完成了逆序递推。</p><p>最后返回结果。</p><h2 id="结语">结语</h2><p>至此，动态规划的基础算是打下了，但要完成动态规划的题目还要掌握一些数据结构和常见动态规划模型（状态转移方程）。我在最开始学习算法时就碰见了动态规划，那时我只自学了一些c++ 和 python 的简单语法，数据结构和算法是两眼一抹黑。看见 memset函数我都蒙了，因此动态规划很长一段时间是我的噩梦，现在我总算解决了。（笑</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Openssl生成并使用自签名CA证书（V3）</title>
    <link href="/post/90465f91.html"/>
    <url>/post/90465f91.html</url>
    
    <content type="html"><![CDATA[<p>最近在搭建局域网环境，涉及到 https时需要使用自签名证书。走了很多弯路，甚至有人说局域网 IP没法签发证书。根据我的测试，证书的颁发是自由的，甚至可以一张证书给所有<code>IP</code>签发，但<code>v1</code>证书签发IP 似乎总是会引发不匹配错误，因此需要签发<code>V3</code>证书。<br /><span id="more"></span> ## 前期准备 V3 证书的签发需要固定的文件夹结构，这点和 V1是不一样的。这个文件夹结构可以在<code>/etc/ssl/openssl.cnf</code>中查看。<br /><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[ CA_default ]</span><br><span class="hljs-attr">dir</span>             = ./demoCA              <span class="hljs-comment"># 生成CA证书的工作目录</span><br><span class="hljs-attr">certs</span>           = <span class="hljs-variable">$dir</span>/certs            <span class="hljs-comment"># 保存生成的 ca 证书</span><br><span class="hljs-attr">crl_dir</span>         = <span class="hljs-variable">$dir</span>/crl              <span class="hljs-comment"># Where the issued crl are kept</span><br><span class="hljs-attr">database</span>        = <span class="hljs-variable">$dir</span>/index.txt        <span class="hljs-comment"># database index file.</span><br><span class="hljs-attr">new_certs_dir</span>   = <span class="hljs-variable">$dir</span>/newcerts         <span class="hljs-comment"># 保存用 CA 签发的其他证书，这里是 pem 格式的备份</span><br><br><span class="hljs-attr">certificate</span>     = <span class="hljs-variable">$dir</span>/cacert.pem       <span class="hljs-comment"># The CA certificate</span><br><span class="hljs-attr">serial</span>          = <span class="hljs-variable">$dir</span>/serial           <span class="hljs-comment"># The current serial number</span><br><span class="hljs-attr">crlnumber</span>       = <span class="hljs-variable">$dir</span>/crlnumber        <span class="hljs-comment"># the current crl number</span><br>                                        <span class="hljs-comment"># must be commented out to leave a V1 CRL</span><br><span class="hljs-attr">crl</span>             = <span class="hljs-variable">$dir</span>/crl.pem          <span class="hljs-comment"># The current CRL</span><br><span class="hljs-attr">private_key</span>     = <span class="hljs-variable">$dir</span>/private/cakey.pem<span class="hljs-comment"># The private key</span><br></code></pre></td></tr></table></figure></p><p>也就是说，如果你不手动配置的话，你的 CA证书目录一定叫<code>demoCA</code> 且 demoCA包含<code>private &amp; newcerts</code>两个子目录。CA证书与密钥的文件名只能是<code>cacert.pem</code>与<code>cakey.pem</code>。## 生成目录结构 先新建一个目录，我取名叫 CA 。然后运行 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ./demoCA/&#123;private,newcerts&#125; &amp;&amp; \<br>    <span class="hljs-built_in">touch</span> ./demoCA/index.txt &amp;&amp; \<br>    <span class="hljs-built_in">touch</span> ./demoCA/serial &amp;&amp; \<br>    <span class="hljs-built_in">echo</span> 01 &gt; ./demoCA/serial<br></code></pre></td></tr></table></figure></p><h2 id="签发ca证书">签发CA证书</h2><p>创建 CA 配置文件 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> CA.cnf<br></code></pre></td></tr></table></figure></p><p>文件内容 <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[ req ]</span><br> <br><span class="hljs-attr">default_bits</span>        = <span class="hljs-number">2048</span><br><span class="hljs-attr">default_keyfile</span>     = r.pem<br><span class="hljs-attr">default_md</span>          = sha256<br><span class="hljs-attr">string_mask</span>         = nombstr<br><span class="hljs-attr">distinguished_name</span>  = req_distinguished_name<br><span class="hljs-attr">req_extensions</span>      = req_ext<br><span class="hljs-attr">x509_extensions</span>     = x509_ext<br><span class="hljs-section">[ req_distinguished_name ]</span><br> <br><span class="hljs-attr">countryName</span>                 = Country Name (<span class="hljs-number">2</span> letter code)<br><span class="hljs-attr">countryName_default</span>         = CN<br><span class="hljs-attr">stateOrProvinceName</span>         = State or Province Name (full name)<br><span class="hljs-attr">stateOrProvinceName_default</span> = BeiJing<br><span class="hljs-attr">localityName</span>                = Locality Name (eg, city)<br><span class="hljs-attr">localityName_default</span>        = BeiJing<br><span class="hljs-attr">organizationName</span>            = Organization Name (eg, company)<br><span class="hljs-attr">organizationName_default</span>    = Hydrogen CA<br><span class="hljs-attr">commonName</span>                  = Common Name (e.g. server FQDN or YOUR name)<br><span class="hljs-attr">commonName_max</span>              = <span class="hljs-number">64</span><br><span class="hljs-attr">commonName_default</span>          = Hydrogen CA<br><span class="hljs-section">[ x509_ext ]</span><br> <br><span class="hljs-attr">subjectKeyIdentifier</span>   = hash<br><span class="hljs-attr">authorityKeyIdentifier</span> = keyid,issuer<br><span class="hljs-attr">basicConstraints</span>       = CA:<span class="hljs-literal">TRUE</span><br><span class="hljs-attr">keyUsage</span>               = digitalSignature, keyEncipherment, keyCertSign, cRLSign<br><span class="hljs-section">[ req_ext ]</span><br> <br><span class="hljs-attr">subjectKeyIdentifier</span> = hash<br><span class="hljs-attr">basicConstraints</span>     = CA:<span class="hljs-literal">TRUE</span><br><span class="hljs-attr">keyUsage</span>             = digitalSignature, keyEncipherment, keyCertSign, cRLSign<br><br></code></pre></td></tr></table></figure></p><p><code>countryName_default</code>是国家代码<br /><code>organizationName_default</code>是证书机构的名称<br /><code>commonName_default</code>是机构的友好名称<br />其他的可以不改 ### 生成CA证书 生成 CA 证书密钥<br /><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">openssl genrsa -<span class="hljs-keyword">out</span> ./demoCA/<span class="hljs-keyword">private</span>/cakey.pem <span class="hljs-number">2048</span><br></code></pre></td></tr></table></figure></p><p>生成 CA 证书 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl req -new -x509 -key ./demoCA/private/cakey.pem -out ./demoCA/cacert.pem -days 3650 -config CA.cnf<br></code></pre></td></tr></table></figure></p><p>转化为 <code>cer</code>文件（可选） <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl x509 -inform PEM -<span class="hljs-keyword">in</span> ./demoCA/cacert.pem -outform DER -out ./demoCA/CA.cer<br></code></pre></td></tr></table></figure></p><h2 id="签发服务器证书">签发服务器证书</h2><p>服务器证书的文件结构比较自由，命名也随意。我取为test，下面配置服务器的配置文件。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> test.cnf<br></code></pre></td></tr></table></figure></p><p>内容如下 <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[ req ]</span><br> <br><span class="hljs-attr">default_bits</span>        = <span class="hljs-number">2048</span><br><span class="hljs-attr">default_keyfile</span>     = r.pem<br><span class="hljs-attr">default_md</span>          = sha256<br><span class="hljs-attr">string_mask</span>         = nombstr<br><span class="hljs-attr">distinguished_name</span>  = req_distinguished_name<br><span class="hljs-attr">req_extensions</span>      = req_ext<br><span class="hljs-attr">x509_extensions</span>     = x509_ext<br><span class="hljs-section">[ req_distinguished_name ]</span><br> <br><span class="hljs-attr">countryName</span>                 = Country Name (<span class="hljs-number">2</span> letter code)<br><span class="hljs-attr">countryName_default</span>         = CN<br><span class="hljs-attr">stateOrProvinceName</span>         = State or Province Name (full name)<br><span class="hljs-attr">stateOrProvinceName_default</span> = BeiJing<br><span class="hljs-attr">localityName</span>                = Locality Name (eg, city)<br><span class="hljs-attr">localityName_default</span>        = BeiJing<br><span class="hljs-attr">organizationName</span>            = Organization Name (eg, company)<br><span class="hljs-attr">organizationName_default</span>    = Hydrogen CA<br><span class="hljs-attr">commonName</span>                  = Common Name (e.g. server FQDN or YOUR name)<br><span class="hljs-attr">commonName_max</span>              = <span class="hljs-number">64</span><br><span class="hljs-attr">commonName_default</span>          = Hydrogen portainer<br><span class="hljs-section">[ x509_ext ]</span><br> <br><span class="hljs-attr">subjectKeyIdentifier</span>   = hash<br><span class="hljs-attr">authorityKeyIdentifier</span> = keyid,issuer<br><span class="hljs-attr">basicConstraints</span>       = CA:<span class="hljs-literal">FALSE</span><br><span class="hljs-attr">keyUsage</span>               = digitalSignature, keyEncipherment<br><span class="hljs-attr">subjectAltName</span> = @alt_names<br><span class="hljs-section">[ req_ext ]</span><br> <br><span class="hljs-attr">subjectKeyIdentifier</span> = hash<br><span class="hljs-attr">basicConstraints</span>     = CA:<span class="hljs-literal">FALSE</span><br><span class="hljs-attr">keyUsage</span>             = digitalSignature, keyEncipherment<br><span class="hljs-attr">subjectAltName</span> = @alt_names<br><span class="hljs-section">[ alt_names ]</span><br><br><span class="hljs-attr">IP.1</span>    = <span class="hljs-number">10.10</span>.<span class="hljs-number">11.10</span><br><br></code></pre></td></tr></table></figure></p><p><code>organizationName_default</code>需要与 CA 的一致。 域名和 IP 在[alt_names] 中修改，例如 <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">DNS.1</span>   = *.bing.com<br><span class="hljs-attr">DNS.2</span>   = bing.com<br><span class="hljs-attr">IP.1</span>    = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-attr">IP.2</span>    = <span class="hljs-number">10.10</span>.<span class="hljs-number">11.10</span><br></code></pre></td></tr></table></figure></p><p>生成服务器证书的储存目录 <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">mkdir</span> <span class="hljs-keyword">my</span><br></code></pre></td></tr></table></figure></p><p>生成服务器密钥 <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">openssl genrsa -<span class="hljs-keyword">out</span> my/<span class="hljs-keyword">test</span>.pem 2048<br></code></pre></td></tr></table></figure></p><p>生成描述文件 <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">openssl req -new -key my/<span class="hljs-keyword">test</span>.pem -<span class="hljs-keyword">out</span> my/<span class="hljs-keyword">test</span>.csr -config <span class="hljs-keyword">test</span>.cnf<br></code></pre></td></tr></table></figure></p><p>签发证书 <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">openssl <span class="hljs-keyword">ca</span> -<span class="hljs-keyword">in</span> my/<span class="hljs-keyword">test</span>.csr -<span class="hljs-keyword">out</span> my/<span class="hljs-keyword">test</span>.crt -days 365 -extensions x509_ext -extfile <span class="hljs-keyword">test</span>.cnf<br></code></pre></td></tr></table></figure></p><p>完成！<br />文件结构如下 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus">test<br>├── CA<span class="hljs-selector-class">.cnf</span><br>├── demoCA<br>│   ├── CA<span class="hljs-selector-class">.cer</span><br>│   ├── cacert<span class="hljs-selector-class">.pem</span><br>│   ├── index<span class="hljs-selector-class">.txt</span><br>│   ├── index<span class="hljs-selector-class">.txt</span><span class="hljs-selector-class">.attr</span><br>│   ├── index<span class="hljs-selector-class">.txt</span><span class="hljs-selector-class">.old</span><br>│   ├── newcerts<br>│   │   └── <span class="hljs-number">01</span><span class="hljs-selector-class">.pem</span><br>│   ├── private<br>│   │   └── cakey<span class="hljs-selector-class">.pem</span><br>│   ├── serial<br>│   └── serial<span class="hljs-selector-class">.old</span><br>├── my<br>│   ├── test<span class="hljs-selector-class">.crt</span><br>│   ├── test<span class="hljs-selector-class">.csr</span><br>│   └── test<span class="hljs-selector-class">.pem</span><br>└── test<span class="hljs-selector-class">.cnf</span><br><br></code></pre></td></tr></table></figure></p><h2 id="参考引用">参考&amp;引用</h2><p>[1].https://2heng.xin/2018/12/16/your-own-ca-with-openssl/<br />这文章写的太好了，我只是略作改动<br />[2].https://docs.microsoft.com/zh-cn/azure/application-gateway/self-signed-certificates<br />生成 V1 的证书看微软的文档就够了</p>]]></content>
    
    
    
    <tags>
      
      <tag>折腾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>提取图片主要色调-KMeans算法</title>
    <link href="/post/2c6e351a.html"/>
    <url>/post/2c6e351a.html</url>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>K-Means算法是一种十分常见的聚类分析方法，可将数据分为指定的几个集群。下面简述一下算法步骤。## 1.分配第一次中心<br />在数据中挑选几个点作为不同集群的中心，初次挑选的中心会影响最后的分组结果。如下图<span id="more"></span> <imgsrc="https://s3.bmp.ovh/imgs/2022/05/02/138b2a8616503882.png"alt="初次挑选" /> ## 2.计算属于不同中心的数据通常使用距离作为判断依据，数据点属于离它最近的中心 <imgsrc="https://s3.bmp.ovh/imgs/2022/05/02/4918839e9804c0f8.png" /><br />## 3.移动中心将属于同一个中心的数据化为一集群，计算集群的新中心。我选择集群的平均值中心作为新中心，并将原中心移动到新的中心。<br /><img src="https://s3.bmp.ovh/imgs/2022/05/02/f266de869362c93d.png" /> ##4.迭代 重复 2 和 3 步。直到发现中心不再变化，完成。<br /><img src="https://s3.bmp.ovh/imgs/2022/05/02/7ea6a60254de97c0.png" /> ##具体实现 我使用 Python 简单实现了一个例子，实际使用过程中更倾向直接调用SciPY 的现成实现。 ### 生成随机数据<br />在这简单填充随机生成的数据进行测试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">k=<span class="hljs-number">0</span><br>date=np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">225</span>,size=[<span class="hljs-number">100</span>,<span class="hljs-number">2</span>])<br>dateList=[datePoint(i[<span class="hljs-number">0</span>],i[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> date]<br>pointlist=[[random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">225</span>),random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">225</span>)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k)]<br></code></pre></td></tr></table></figure><p><code>k</code>为中心点个数；<code>date</code>为随机生成的数据；<code>dateList</code>保存数据与其所属中心点；<code>pointlist</code>是中心，使用随机数初始化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">datePoint</span>:<br>  x=y=<span class="hljs-number">0</span><br>  point=<span class="hljs-number">0</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,X,Y,Point=<span class="hljs-number">0</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>      self.x=X<br>      self.y=Y<br>      self.point=Point<br></code></pre></td></tr></table></figure><p>我定义了一个类 <code>dateList</code>与<code>datePoint.point</code>来储存数据点与它所属的中心。<br />### 计算数据点所属的中心<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calPoint</span>(<span class="hljs-params">dateList:<span class="hljs-built_in">list</span>,pointList:<span class="hljs-built_in">list</span></span>):<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dateList:<br>    flag=<span class="hljs-number">10000000</span> <span class="hljs-comment">#一个足够大的数字</span><br>    <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(pointList)):<br>      <span class="hljs-keyword">if</span>(flag&gt;((i.x-pointList[ii][<span class="hljs-number">0</span>])**<span class="hljs-number">2</span>+(i.y-pointList[ii][<span class="hljs-number">1</span>])**<span class="hljs-number">2</span>)):<br>        flag=(i.x-pointList[ii][<span class="hljs-number">0</span>])**<span class="hljs-number">2</span>+(i.y-pointList[ii][<span class="hljs-number">1</span>])**<span class="hljs-number">2</span><br>        i.point=ii<br></code></pre></td></tr></table></figure></p><p>遍历每一个数据点，在第二个循环中检查每一个中心到该点的距离，选择最小的那个。这里使用了一个足够大的数字保证第一次计算的距离会小于这个假想的中心点。<br />### 移动中心点 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">change_point</span>(<span class="hljs-params">dateList:<span class="hljs-built_in">list</span>,pointList:<span class="hljs-built_in">list</span></span>):<br>  new_point_list=[[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k)]<br>  nums_point=[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k)]<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dateList:<br>    new_point_list[i.point][<span class="hljs-number">0</span>]+=i.x<br>    new_point_list[i.point][<span class="hljs-number">1</span>]+=i.y<br>    nums_point[i.point]+=<span class="hljs-number">1</span><br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>    pr=new_point_list[i]<br>    pr[<span class="hljs-number">0</span>]=<span class="hljs-built_in">int</span>(pr[<span class="hljs-number">0</span>]/nums_point[i])<br>    pr[<span class="hljs-number">1</span>]=<span class="hljs-built_in">int</span>(pr[<span class="hljs-number">1</span>]/nums_point[i])<br>  <span class="hljs-keyword">if</span> new_point_list!=pointList:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>      pointList[i][<span class="hljs-number">0</span>]=new_point_list[i][<span class="hljs-number">0</span>]<br>      pointList[i][<span class="hljs-number">1</span>]=new_point_list[i][<span class="hljs-number">1</span>]<br>    <span class="hljs-built_in">print</span>(pointList)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>  <span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure></p><p>先定义了一个数组 <code>new_point_list</code>来储存新计算的中心点，然后 <code>nums_point</code>储存属于每一个中心点的数据个数以方便最后计算平均值。在我这个精度下，点取整数即可。最后一个<code>if</code> 用于判断中心发生了改变，就返回 <code>True</code> 反之为<code>False</code>. ### 一些收尾工作 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> change_point(dateList,pointlist):<br>  calPoint(dateList,pointlist)<br><span class="hljs-built_in">print</span>(pointlist)<br></code></pre></td></tr></table></figure> 不停的迭代 2 和 3步，直到中心不再移动。最后输出结果即可。</p><h2 id="参考">参考</h2><p>[1].https://aishack.in/tutorials/kmeans-clustering/</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用加密的虚拟硬盘安全存储学习资料</title>
    <link href="/post/11014277.html"/>
    <url>/post/11014277.html</url>
    
    <content type="html"><![CDATA[<h2 id="序">序</h2><p>众所周知，21世纪的青少年到了一定的年纪总会积累下一大批的学习资料。如果你像我一样是属仓鼠的，你将不可避免的产生隐秘的储存学习资料的需求，除非你是社交恐怖分子。啥也不知道的新司机以为多重嵌套文件夹就万事大吉，最多启用隐藏文件夹。大部分老司机可能会选择使用加密的压缩包来储存资料，毕竟压缩包简单好使，如果没有经常复习的需求已经够用了。但如果你想更近一步，使用更加高级且舒适的方法，这文章值得你看下去。虽然准备稍复杂，但日后体验绝对很棒。<br /><span id="more"></span> <strong>以下操作均在 Windows10/11 下完成</strong><br />## 创建虚拟硬盘虚拟硬盘是一种特殊的文件，它像其他文件比如PPT和图片一样可以自由复制或移动。但使用时只需“挂载”，计算机便会出现一个新的硬盘，对于应用程序来说它就是普通的硬盘，也就是说你该咋用就咋用，不碍事。好啦，下面我们来创建一个虚拟硬盘吧。<br />首先你要决定创建<strong>动态虚拟硬盘</strong>还是<strong>固定虚拟硬盘</strong>，下面简称为动态硬盘和固定硬盘。动态硬盘一开始占用空间很小，但随着填充内容会逐渐变大直到设定大小。固定硬盘的大小一开始就设定完成，不够用了可以手动扩充，但对于加密的硬盘来说扩充更加困难，优点是比动态硬盘性能好一些。<br />### 命令行创建（可能需要专业版） <strong>确保下文的所有 PowerShell命令以管理员身份运行</strong><br />创建动态硬盘（因为大小是动态增大的，设定值容量高一些比较好）：<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">New</span>-VHD -<span class="hljs-type">Path</span> c:\base.vhdx -SizeBytes <span class="hljs-number">100</span>GB<br></code></pre></td></tr></table></figure> 不出意外会C 盘根目录下产生一个 5MB 大小的base.vhdx文件创建固定硬盘： <figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">New</span><span class="hljs-operator">-</span><span class="hljs-variable">VHD</span> <span class="hljs-operator">-</span><span class="hljs-built_in">Path</span> <span class="hljs-built_in">C</span><span class="hljs-operator">:</span>\<span class="hljs-variable">fixed</span><span class="hljs-operator">.</span><span class="hljs-variable">vhd</span> <span class="hljs-operator">-</span><span class="hljs-variable">Fixed</span> <span class="hljs-operator">-</span><span class="hljs-variable">SizeBytes</span> <span class="hljs-number">10</span><span class="hljs-variable">GB</span><br></code></pre></td></tr></table></figure> C盘根目录下产生一个 10GB 的fixed.vhd文件### GUI创建 * Win+x并点击磁盘管理 * 单击 “操作（A）” 并选择 “创建VHD”<img src="https://s3.bmp.ovh/imgs/2022/04/29/5a40d0823c7ec9ab.png" /> *位置随你喜欢，虚拟硬盘大小选择 GB 并且越大越好 * 硬盘类型选择 “动态扩展”，VHD 还是 VHDX 随你喜欢 <imgsrc="https://s3.bmp.ovh/imgs/2022/04/29/3c93432f669eba68.png" /> ##格式化虚拟硬盘 这里统一使用GUI格式化<br />* 右键新出现的硬盘，注意不要点到分区那里了 <imgsrc="https://s3.bmp.ovh/imgs/2022/04/29/fed1927d32b8ef12.png" /> *初始化硬盘 * 选择 MBR 和 GPT其实差不多，但如果你的系统不是专业版，我推荐 MBR * 确定 *右键分区，新建简单卷，一直下一步，完成即可<br /><img src="https://s3.bmp.ovh/imgs/2022/04/29/6ac80240d89cc854.png" />好了，现在你应该可以看见一块新的空硬盘了<br />## 加密 这里又有两个选则。如果你使用的是专业版系统，并且以后一定只在Windows 环境下学习我推荐你选择 BitLocker 加密。这只适用于 Windows系统但体验最好。如果你不是专业版或者以后也许会换 Mac 或者 Linux环境，我要向你推荐大名鼎鼎的 VeraCrypt 加密软件。<br />### Bitlocker加密 * 在资源管理器之中右键新分区 * 选择 “启用Bitlocker” *设置密码 * 选一个你喜欢的保存选项 * 一直下一页，完成即可<br />Bitlocker 加密完成，下面的 VeraCrypt可以跳过。<br />### VeraCrypt加密<br />* (下载VeraCrypt)https://launchpad.net/veracrypt/trunk/1.25.9/+download/VeraCrypt%20Portable%201.25.9.exe* 运行 VeraCrypt.exe <imgsrc="https://s3.bmp.ovh/imgs/2022/04/29/16fbb54ae7ce942d.png" /> *如果你是英语界面，选择 “Setting”-&gt;“language”找到中文即可 * 单击“加密卷”-&gt;“创建加密卷” * “加密非系统分区/设备” * 标准加密卷即可 <imgsrc="https://s3.bmp.ovh/imgs/2022/04/29/cc717be09776fa92.png" /> *选择有 “新加卷” 且大小符合你设定值的硬盘 * 下一步，直到 “加密选项” *哈希算法一栏我推荐 “SHA-256”，毕竟越快越好 <imgsrc="https://s3.bmp.ovh/imgs/2022/04/29/2001ca89a75f33ef.png" /> *下一步~ * 填写密码 * 大文件选择推荐 “是” * 进入 “加密卷格式化”步骤后在小窗口内不停移动鼠标直到进度条变绿且跑满 <imgsrc="https://s3.bmp.ovh/imgs/2022/04/29/f81bac2c0df3dc40.png" /> *格式化~等待一会，电脑可能会卡 * 要仔细阅读警告哦!!! *关掉窗口，已经加密完了<br />#### VeraCrypt挂载<br />日后使用时，先按下文的步骤挂载虚拟硬盘，然后打开 VeraCrypt.exe 在ABCDEF……里随便选一个，点击自动挂载设备，解密~完成！这里我解释一下为什么选择 MBR硬盘：在我的电脑上，GPT类型的硬盘自动挂载会卡很久，可能是因为多了一个引导分区导致的。反正这硬盘也不装系统，MBR就很好用。 ## 挂载与弹出硬盘 ### 挂载 win+x 进入磁盘管理，点击“操作（A）”，选择 “附加VHD“ 找到虚拟硬盘文件即可。 ### 弹出硬盘 使用了VeraCrypt 加密的同学，请先运行 VeraCrypt 并点击 “全部卸载“。之后再进入磁盘管理，右键虚拟磁盘，点击 ”分离VHD“，确定即可。 ## 结语经过以上操作，你已经掌握了高级的文件隐藏技巧。上述资料存储的进化过程是我的亲身经历，技术力不断进步，工具越来越复杂，但想在生活中更加舒适的愿望没有改变。可以说是不忘初心了（笑。相信掌握新方法的你日后学习一定能更上一层楼，去异世界之前再也不用拜托后辈清空硬盘了！</p>]]></content>
    
    
    
    <tags>
      
      <tag>折腾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原点</title>
    <link href="/post/b1be357.html"/>
    <url>/post/b1be357.html</url>
    
    <content type="html"><![CDATA[<h1 id="原点">原点</h1><p>建站的第一篇文章，我应该写啥好呢？<br />算了，本来肚子里就没啥墨水，强行高雅只会引起自我厌恶。这次就一个目标，争取不要像上一个小站一样暴毙。<br />不过，我还是想说说上一个博客，顺便发发牢骚。反正除了爬虫也少有访问，这里权当一个“大胆的树洞”。<span id="more"></span><br />关于上一个博客，我用了一个小众的工具。当时我比现在还菜，特别喜欢图形界面，于是使用了Gridea 作为根基。这是我从少数派上了解到的一个“玩具”。不过我的博客和它一样，最开始很兴奋，然后慢慢的变成——“好麻烦啊！又没几个人用，算啦吧。”，最后就不更新了。这是很多博客和开源软件的命运，没有大量的用户和利益刺激，兴奋消退后只有自嘲。经过我的总结，这种情况大多数是因为过高的目标和期望所导致的。我们又不是少数大佬，隔几天就有超大的技术积累，超新颖的人生感悟，所以一开始就明白自己不会有太多的干货，摆正心态才能稳定更新！<strong>但坚决不转载，这种无意义的复制只会产生垃圾!</strong><br />注意，我不是过河拆桥哈。我其实很向往这种可以开发自己的软件然后还有人用的程序员生活，毕竟我估计是做不到了。现在的我一切从简，选择了HEXO和 NexT来搭建博客。我只希望这次博客可以稳定更新，至少一个月一篇吧。<br />在我这，不可避免的会出现“搭建日记，管理类笔记，算法知识，生活记录，游戏内容”。<br />下面用狄兰·托马斯的《不要温和地走进那个良夜》结尾喽。<br />&gt;不要温和地走进那良夜，<br />&gt;老年应当在日暮时燃烧咆哮；<br />&gt;怒斥，怒斥光明的消逝。<br />&gt;虽然智慧的人临终时懂得黑暗有理，<br />&gt;因为他们的话没有迸发出闪电，<br />&gt;他们也并不温和地走进那个良夜。<br />&gt;善良的人，当最后一浪过去，高呼他们脆弱的善行<br />&gt;可能曾会多么光辉地在绿色的海湾里舞蹈，<br />&gt;怒斥，怒斥光明的消逝。<br />&gt;狂暴的人抓住并歌唱过翱翔的太阳，<br />&gt;懂得，但为时太晚，他们使太阳在途中悲伤，<br />&gt;也并不温和地走进那个良夜。<br />&gt;严肃的人，接近死亡，用炫目的视觉看出<br />&gt;失明的眼睛可以像流星一样闪耀欢欣，<br />&gt;怒斥，怒斥光明的消逝。<br />&gt;您啊，我的父亲。在那悲哀的高处。<br />&gt;现在用您的热泪诅咒我，祝福我吧。<br />&gt;我求您不要温和地走进那个良夜。<br />&gt;怒斥，怒斥光明的消逝。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/post/4a17b156.html"/>
    <url>/post/4a17b156.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
