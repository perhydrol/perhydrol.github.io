<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>客观合理地期待星空（Starfield)</title>
    <link href="/post/b6d2dc63.html"/>
    <url>/post/b6d2dc63.html</url>
    
    <content type="html"><![CDATA[<p>星空直面会结束了，45min 的干货，基本展示了游戏的每一个模块。没有看的可以看看B站的搬运<a href="https://www.bilibili.com/video/BV15u4y1o7rx/?p=1">【中文字幕】星空Starfield直面会全流程)</a>。但我注意到，有很多不了解B社的玩家对游戏有不合理的期待或者过度地贬低。我觉得我应该讲讲我的观点，希望能使大家对星空有合理的预期。</p><p>总共有三个部分：可以预计有哪些问题、明明有这么多问题我们为什么选择相信星空、我期待星空有哪些内容。</p><hr><h1 id="先泼冷水——可以预见有哪些问题"><a href="#先泼冷水——可以预见有哪些问题" class="headerlink" title="先泼冷水——可以预见有哪些问题"></a>先泼冷水——可以预见有哪些问题</h1><h2 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h2><p>这几年的大作就没几个是首发无BUG的，有开创历史的《赛博朋克2077》和连外挂都放弃了的《战地2042》，哪怕是《塞尔达：王国之泪》首日也无法流畅运行。貌似就老头环正常点？（宫崎英高跌落神坛）</p><p>那么，B社和微软这两大BUG大厂强强联手，首发必定BUG漫天。<a href="https://www.bilibili.com/video/BV1T8411t7Dv/">《上古卷轴》巨人航空</a></p><p><img src="https://s3.bmp.ovh/imgs/2023/06/12/7d68c00f5f77defb.jpg" alt="你一定不陌生"></p><h2 id="1000颗星球"><a href="#1000颗星球" class="headerlink" title="1000颗星球"></a>1000颗星球</h2><p>B社！陶德！1000颗星球！《辐射3》有200个结局！“看见那座山了吗？你可以爬上去”！Fallout 76 is 4x the size of Fallout 4！</p><p>客观的说，吹牛可不是B社独家，波兰蠢驴的史诗巨作——《赛博朋克2077》也声称“无脚本演出”。毕竟你在发布会不整点噱头真没人看你。</p><p>现在大家都知道，技术上限就那样，GPT和英伟达的H100才碰到了全实时剧情的门槛，这还是这两年刚刚出的技术，等应用在3A大作上还早。你可以期待任何东西，就不应该期待这1000颗星球（题外话，英伟达实时生成的那段视频效果真的不错，我很期待业界发展 <a href="https://www.bilibili.com/video/BV1om4y1x7x8/">将AI加入游戏开发！英伟达发布GH200超极计算机</a> ）</p><h2 id="不算出色的画质和射击手感"><a href="#不算出色的画质和射击手感" class="headerlink" title="不算出色的画质和射击手感"></a>不算出色的画质和射击手感</h2><p>画质和手感从来不是B社的强项，我最担心出现“画质和顽皮狗（最后生还者2）比，射击手感和使命召唤比”的要命评价。</p><p>客观的来说，画质相较B社自己的前作肯定是巨大的提升，射击手感相较《辐射4》必然有所改进，但你要是玩田忌赛马式的比较，我只能说“确实！”，不然呢？确实比不了啊。但这会影响我继续捡垃圾吗？ε&#x3D;( o｀ω′)ノ</p><h2 id="每颗星球都十分巨大？可能吗？"><a href="#每颗星球都十分巨大？可能吗？" class="headerlink" title="每颗星球都十分巨大？可能吗？"></a>每颗星球都十分巨大？可能吗？</h2><p>先不说超大星球的工作量，就是真有1000颗超大星球，150G的游戏它塞得下这么多东西嘛？知名二字开放世界游戏「原神」，目前就4个大地图，PC端已经30G了，要是「星空」每颗星球大小相当于「原神」一个国家的大小，这游戏储存大小没法玩了好吧。除非……它学 Minecraft，980颗星球随机拼接地图，实时生成地图确实有可能。但我不太看好，估计980颗星球相当于980个大型地牢比较符合实际。</p><hr><h1 id="信陶，爱陶，等陶——为什么我依旧期待《星空》"><a href="#信陶，爱陶，等陶——为什么我依旧期待《星空》" class="headerlink" title="信陶，爱陶，等陶——为什么我依旧期待《星空》"></a>信陶，爱陶，等陶——为什么我依旧期待《星空》</h1><p><strong>因为它是 Bethesda 的最新力作，那个制作了《上古卷轴：天际》的 Bethesda，那个即使《辐射4》是“一坨”我也玩的不亦乐乎的 Bethesda</strong></p><p>我很难向没玩过B社作品的玩家解释，为什么B社的开放世界如此独特。或许只有B社自己的那句，“做你自己，这是属于你的故事”才最贴切。</p><blockquote><p>create any character you want and explore with unparalleled freedom as you embark on an epic journey</p></blockquote><h2 id="都是B社了，这你能不打个MOD吗！？"><a href="#都是B社了，这你能不打个MOD吗！？" class="headerlink" title="都是B社了，这你能不打个MOD吗！？"></a>都是B社了，这你能不打个MOD吗！？</h2><p>乔布斯有一句名言：“顾客不知道自己想要什么（People don’t know what they want）。”但我要说——“游戏真的会自己长出来！” <img src="https://s3.bmp.ovh/imgs/2023/06/12/6076998d94f4a97b.png" alt="只有 Minecraft 才能与之抗衡"></p><p>从你进入游戏的一瞬间，鼠标能触碰的么一个点，MOD都能修改。玩腻了《辐射4》的铁管武器？打个MOD，现代武器任君选。<img src="https://s3.bmp.ovh/imgs/2023/06/12/07cf0a8eab0f248c.png"></p><h2 id="连BUG都能修！"><a href="#连BUG都能修！" class="headerlink" title="连BUG都能修！"></a>连BUG都能修！</h2><p>我不太担心B社的BUG，或者是B社为什么有胆量留着一众祖传BUG发售，都是MOD社区给它惯的╰（‵□′）╯<img src="https://s3.bmp.ovh/imgs/2023/06/12/15b35ed35a7ebeaf.png"></p><h2 id="我想要二次元o-〃＾▽＾〃-o"><a href="#我想要二次元o-〃＾▽＾〃-o" class="headerlink" title="我想要二次元o(〃＾▽＾〃)o"></a>我想要二次元o(〃＾▽＾〃)o</h2><p><img src="https://s3.bmp.ovh/imgs/2023/06/12/2cbdb73258ee5929.png"></p><p>我想瑟瑟……，咳咳，前面的区域自己去探索吧。</p><h2 id="这些我们都做过，熟练了"><a href="#这些我们都做过，熟练了" class="headerlink" title="这些我们都做过，熟练了"></a>这些我们都做过，熟练了</h2><p>看似很多内容，很多东西在《上古卷轴》和《辐射》都有影子。我发现很多人都希望3A大作与大公司能有巨大的创新，我认为这不合理。大公司已经没有勇气去花大代价试错了，特别是Xbox 已经是主机市场的弱者，B社的口碑才好一点点。将自己从未尝试的领域作为主打产品就是下一个《红霞岛》，我之所以对星空有信心，正是因为我没看见陶德准备整大活，1000颗星球除外，没人会期待这个。其他的部分，都是B社的老本行，熟练了。</p><hr><h1 id="我期待星空什么？"><a href="#我期待星空什么？" class="headerlink" title="我期待星空什么？"></a>我期待星空什么？</h1><p>很明显，B社从《辐射4》吸取的教训，比如：改进枪械手感（找了做DOOM的同事帮忙）、主角取消配音（这确实不是退步，当年辐射4主角加入配音导致一种MOD无法正常工作）、点的技能终于又能影响剧情了（这是很多人从《辐射：新维加斯》转到《辐射4》最不满意的地方，辐射4主角点口才技能只能用来讨价还价）</p><h2 id="可能会出现的随机地图，这是我的推测"><a href="#可能会出现的随机地图，这是我的推测" class="headerlink" title="可能会出现的随机地图，这是我的推测"></a>可能会出现的随机地图，这是我的推测</h2><p><img src="https://s3.bmp.ovh/imgs/2023/06/12/21303c1d779118e6.png"><br><img src="https://s3.bmp.ovh/imgs/2023/06/12/f08423c56ae5fffd.png"></p><p>这似乎是同一个地点，但出现了不同的建筑。我推测类似 Minecraft 里的沙漠神殿和丛林神庙这种建筑机制，在特定类型的地方可能随机生成建筑。不过我推测，B社将建筑和地点分成了可以随机生成和不可随机生成两种，小建筑随机生成，大建筑与剧情相关固定地点。</p><hr><p>最后，为了防止话说得太满，以一句“星空！褒姒！”结尾吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>感想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不讲爱情了？「铃芽之旅」超主观感受</title>
    <link href="/post/82d6fc97.html"/>
    <url>/post/82d6fc97.html</url>
    
    <content type="html"><![CDATA[<p>四年一次，我还记得初中第一次和同学一起去影院看「你的名字」的事情。在那个“二次元”还是小众，叔叔还在苦恼 B站 的路在何方的时候。我不知道什么是“新海诚”、「秒速五厘米」，就踏进了影院。后来的「天气之子」和今天的「铃芽之旅」，光是”新海诚“这三个字就让我乖乖掏钱了。今天，我走出影院，不由感叹技术与画面的进步，但剧情我只能说差强人意。</p><p><strong>以下涉及剧透！！</strong></p><h1 id="先来说说优点"><a href="#先来说说优点" class="headerlink" title="先来说说优点"></a>先来说说优点</h1><h2 id="精致的画面与优秀的音乐"><a href="#精致的画面与优秀的音乐" class="headerlink" title="精致的画面与优秀的音乐"></a>精致的画面与优秀的音乐</h2><p>用大家常说的话：“每一帧都是壁纸。”虽然这可能有点夸张，但是这部影片所呈现的如此美妙的画面，确实让人赏心悦目，这点是确凿无疑的。无论是船上的 “人和椅子追猫” 这一段流畅的动作，还是在关键时刻使用的音乐和演出，都表现出了技术带来的巨大进步以及经费过分的充足。这让我不禁感到头皮发麻、心情激动。随着这部影片的热度不断升高，我能预见未来将有很多奇怪标题的MAD视频相继涌现。</p><h2 id="故乡情结"><a href="#故乡情结" class="headerlink" title="故乡情结"></a>故乡情结</h2><p>在城市的快速发展过程中，拆除与重建几乎不可避免。对那些未能重建的建筑，它们往往被直接遗弃，就像电影剧情中的废弃学校和游乐园，它们在出场时早已变成了废墟，荒凉和破败。尽管如此，这些废墟仍然承载着人们的过去和回忆，代表着那些曾经的繁荣和兴盛。而在现实生活中，我常常会在附近的公园中看见时光荏苒的痕迹，让我感叹岁月如梭。</p><h2 id="情亲"><a href="#情亲" class="headerlink" title="情亲"></a>情亲</h2><p>经过对剧情的反复探讨，部分观众不免对电影中存在的瑕疵进行吐槽。然而，在当今信息爆炸的二极管年代，仅仅凭借”就是依托答辩”这句话来概括电影的整个故事显然是缺乏深度和客观性的。尽管如今电影作品越来越缺乏新意，甚至就像逝去的风一般转瞬即逝，但这并不表明电影失去了多彩斑斓的本质，因为故事的魅力在人性的复杂性和故事情节的丰富性。</p><p>正如先前所述，电影中女主角铃芽与姨妈的故事是一个相对得当的切入点。姨妈收养了铃芽，生活计划被彻底打散，依靠自身的母爱在年少时带着孩子生活，她的勇气和经历让人感叹。然而与此同时，铃芽也被姨妈的严厉和“沉重的爱”所压迫，这场情感博弈在雨中的停车场达到了高潮，姨妈愤怒的哭喊也深刻的反映出她内心的痛苦和矛盾，”带着孩子，对象也不好找，这样就算有姐姐的遗产我也不愿意啊！“。然而，正如片中姨妈所强调的：“那虽然也是我的想法，但那并不是全部。”，人的想法和情感都是复杂而丰富的，也正是这些复杂而多面的情感交织，给人物带来了深刻的内涵和魅力，为其注入了强大的生命力。</p><p>这条线，相较于几乎是铃芽独白的爱情线更令我满意，有感情沉淀和冲突，双方的想法也都有所展现，还是很有共鸣的。</p><h1 id="当然要有缺点啦"><a href="#当然要有缺点啦" class="headerlink" title="当然要有缺点啦"></a>当然要有缺点啦</h1><h2 id="爱情"><a href="#爱情" class="headerlink" title="爱情"></a>爱情</h2><p>这部电影的主要问题之一在于男主角草太和铃芽之间的感情发展似乎过于突然和迅速。我认为这种速度令人难以置信，尤其当草太先生未能有效表达自己的感受时，这使得我会觉得铃芽有点盲目追求，在唱独角戏。在回顾整部电影之后，我认识到故事中他们的相遇和感情的发展只有几天的时间，这似乎有点仓促了，简直和现在的快餐式情侣一样，电影中应该给他们更多的时间与空间来相互了解和沉淀感情。否则剧情发生转折常令我产生难以消化的疑惑。以至于，最后把化为封印石的男主拔出来，换回猫猫封印石时，我一度疑惑猫猫做错了什么？为什么要这么对它？</p><h2 id="小孩子才全都要，大人知道身体不好"><a href="#小孩子才全都要，大人知道身体不好" class="headerlink" title="小孩子才全都要，大人知道身体不好"></a>小孩子才全都要，大人知道身体不好</h2><p>电影想表达的东西太多了，铃芽与母亲、铃芽与草太、铃芽与姨妈，再加上是个”公路片“。一群工具人，过几天就忘记他们是谁了。未能让我真切感受到每个人物真正深层的想法和情感，导致我与主角之间缺少共鸣感。常常有：”你谁啊？你干嘛啊？“的疑惑。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>能看，下次的“新海诚”我还会去看。但……哎！还行吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>随手记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不要无限恐惧</title>
    <link href="/post/ae359897.html"/>
    <url>/post/ae359897.html</url>
    
    <content type="html"><![CDATA[<p>恐惧能推动人行动。一直以来，我都像个胆小鬼，担忧这个担忧那个地。在恐惧下，我的心态像个橡皮筋，恐惧把我向后拽，我的努力把我向前拽。越是恐惧，我就越发的努力；而努力带来的沉没成本又使我越发惧怕失败。直到有一天，橡皮筋终于到达极限了，“啪”，断裂了。</p><p>也如同橡皮筋，断裂之后的两半会更加难以拉伸。反复的失败就像反复断裂的橡皮筋，反复断裂后，恐惧难以激发动力，简单来说就是躺平了。“摆起来！”</p><p>但《山月记》写得好：</p><blockquote><p>因为害怕自己并非明珠而不敢刻苦琢磨，又因为有几分相信自己是明珠，而不能与瓦砾碌碌为伍，遂逐渐远离世间，疏避人群，结果在内心不断地用愤懑和羞怒饲育着自己懦弱的自尊心。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>随手记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>检查字符串是否为合法文件路径-Python3</title>
    <link href="/post/a0f6072d.html"/>
    <url>/post/a0f6072d.html</url>
    
    <content type="html"><![CDATA[<p>在 Python3 中如何检查一个字符串能否成为文件路径？即使这个文件现在还不存在，但当你要按路径创建时它能创建成功。显然 os.isdir() 等函数不能满足我们的要求，因为 <code>os.isdir()</code> 要求文件已经存在。我的笔记将解决这个问题。</p><span id="more"></span><h2 id="定义“合法”"><a href="#定义“合法”" class="headerlink" title="定义“合法”"></a>定义“合法”</h2><p>什么样的路径是合法的呢？一般来说，合法有效的文件路径有以下几点：</p><ol><li>不包含空字节（即 Python 中的 \x00 ）。这是所有 POSIX 兼容文件系统的硬性要求。</li><li>路径中不含有超过 255 个字符（&lt;&#x3D;255）的组件，简单来说就是文件夹和文件的名字不超过 255 个字符</li><li>在 Windows 中文件路径的根会是一个驱动器（比如：C:\ )</li><li>在 POSIX 中文件路径的根会是<code>根目录</code> ( &#x2F; )</li></ol><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><ol><li>检验字符串的合法性</li><li>避免不必要的写入，即先试图创建文件再校验的实现方式</li><li>在路径位于慢速驱动器时依旧能快速检验，以防止多次检验造成的卡顿（比如将网络挂载为驱动器进行访问）</li></ol><h2 id="一些-Python-知识"><a href="#一些-Python-知识" class="headerlink" title="一些 Python 知识"></a>一些 Python 知识</h2><h3 id="os-stat-和-os-lstat"><a href="#os-stat-和-os-lstat" class="headerlink" title="os.stat() 和 os.lstat()"></a>os.stat() 和 os.lstat()</h3><blockquote><p>获取文件或文件描述符的状态。在所给路径上执行等效于 stat() 系统调用的操作。path 可以是字符串类型，或（直接传入或通过 PathLike 接口间接传入的） bytes 类型，或打开的文件描述符。返回一个 stat_result 对象。—— Python 3.11.1 文档</p></blockquote><blockquote><p>在给定路径上执行本函数，其操作相当于 lstat() 系统调用，类似于 stat() 但不跟踪符号链接。返回值是 stat_result 对象。在不支持符号链接的平台上，本函数是 stat() 的别名。从 Python 3.3 起，此功能等价于 os.stat(path, dir_fd&#x3D;dir_fd, follow_symlinks&#x3D;False)。 —— Python 3.11.1 文档</p></blockquote><p>但我们的目标不是这个，我们的目标是它将会抛出的异常：</p><ol><li>FileNotFoundError ：如果路径组件不存在</li><li>TypeError ：路径存在，但包含空字节</li><li>OSError ：路径存在，但字符长度超过 255 字节</li><li>winerror : 在 Windows 下,winerror 属性为 123 （即 ERROR_INVALID_NAME ）文件名、目录名或卷标语法不正确</li></ol><p>比如 &#x2F;etcc&#x2F;aaaaa….aaaa (256 个 a 且不存在 etcc 目录 ) 会抛出 <code>FileNotFoundError</code> 但 &#x2F;etc&#x2F;aa….aaa (256 个 a 且存在 etc 目录) 会抛出 <code>OSError</code>。</p><p>总结一下，<code>lstat()</code> 会优先检查路径是否存在，然后是文件是否存在。注意，目录或者说文件夹也是文件。也就是说，我们保证路径存在就可以检查文件的合法性。</p><h2 id="算法规划"><a href="#算法规划" class="headerlink" title="算法规划"></a>算法规划</h2><ol><li>将路径拆分为路径组件（’&#x2F;etc&#x2F;apt&#x2F;‘ 变成 [‘etc’,’apt’]）</li><li>在一定存在且访问迅速的路径下调用 os.stat() 对路径判断。根目录或<code>%HOMEDRIVE%</code>（Windwos 安装的驱动器，比如 C:\）是一个不错的选择（os.stat(‘&#x2F;‘+’etc’))</li><li>不停尝试，利用分治的思想，部分合法组成的大问题也合法</li></ol><h2 id="开始实现"><a href="#开始实现" class="headerlink" title="开始实现"></a>开始实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> errno,os,sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">IsPathnameValid</span>(<span class="hljs-params">pathname:<span class="hljs-built_in">str</span></span>)-&gt;<span class="hljs-built_in">bool</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;检验传入的字符串是否为文件路径</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        pathname (str): 可能是文件路径的字符串</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Returns:</span><br><span class="hljs-string">        bool: True 为符合</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    ERROR_INVALID_NAME = <span class="hljs-number">123</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(pathname,<span class="hljs-built_in">str</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> pathname:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <br>        _,pathname=os.path.splitdrive(pathname)<br><br>        root_dirname=os.environ.get(<span class="hljs-string">&#x27;HOMEDRIVE&#x27;</span>,<span class="hljs-string">&#x27;C:&#x27;</span>) <span class="hljs-keyword">if</span> sys.platform==<span class="hljs-string">&#x27;win32&#x27;</span> <span class="hljs-keyword">else</span> os.path.sep<br>        <span class="hljs-keyword">assert</span> os.path.isdir(root_dirname)<br><br>        root_dirname=root_dirname.strip(os.path.sep)+os.path.sep<br><br>        <span class="hljs-keyword">for</span> pathname_part <span class="hljs-keyword">in</span> pathname.split(os.path.sep):<br>            <span class="hljs-keyword">try</span>:<br>                os.lstat(root_dirname+pathname_part)<br><br>            <span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> exc:<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(exc,<span class="hljs-string">&#x27;winerror&#x27;</span>):<br>                    <span class="hljs-keyword">if</span> exc.winerror==ERROR_INVALID_NAME:<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">elif</span> exc.errno <span class="hljs-keyword">in</span> &#123;errno.ENAMETOOLONG,errno.ERANGE&#125;:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">except</span> TypeError <span class="hljs-keyword">as</span> exc:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://stackoverflow.com/questions/9532499/check-whether-a-path-is-valid-in-python-without-creating-a-file-at-the-paths-ta/9532586#9532586">https://stackoverflow.com/questions/9532499/check-whether-a-path-is-valid-in-python-without-creating-a-file-at-the-paths-ta/9532586#9532586</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX 表格教程（tabularx 与自动换行、自动计算列宽）</title>
    <link href="/post/a178f8a9.html"/>
    <url>/post/a178f8a9.html</url>
    
    <content type="html"><![CDATA[<p>LaTeX 的表格排版总是痛苦的，特别是你碰见了表格单元是由一段一段的文字构成的时候，表格排版会痛不欲生。在这种条件下，我要介绍 tabularx 包来帮助我们实现<strong>表格内自动换行与自动计算列宽</strong>，它能帮助我们缓解痛苦，愉快工作。</p><span id="more"></span><h2 id="在一切开始之前"><a href="#在一切开始之前" class="headerlink" title="在一切开始之前"></a>在一切开始之前</h2><ol><li>tabularx 有用吗？tabular 不够好吗？</li></ol><p>首先，tabularx 与 tabular 不是替代关系。并且没有一定要使用 tabularx 的理由，它只是提供了自己的改进功能，帮助我们在某些情况下更快的编写表格。</p><ol start="2"><li>什么时候 tabularx 更好用？</li></ol><p>当你需要计算相对于总宽度的列宽时，tabularx 更加好用。请注意，如果你的列宽很短且不包含换行符，则使用 tabularx 不会获得任何好处。你可以使用常规 p 或 wl 说明符的 tabular 来固定列的宽度。</p><ol start="3"><li>有类似的例子吗？</li></ol><ul><li>表格内有大段的文字时</li><li>表格有几个相等宽度的列，并且内部需要换行</li><li>已经不想去计算表格宽度的时候</li></ul><h2 id="可恶的表格与可爱的表格"><a href="#可恶的表格与可爱的表格" class="headerlink" title="可恶的表格与可爱的表格"></a>可恶的表格与可爱的表格</h2><p><img src="https://s3.uuu.ovh/imgs/2022/12/11/af34daa77458d931.png" alt="可爱的表格（简单）"></p><p>上面的表格构成简单，简单编写后就很好看。无论内容是否简练，至少文字清晰。但下面这个表格就不行了。</p><p><img src="https://s3.uuu.ovh/imgs/2022/12/11/a7742d43d63b46b3.png" alt="可恶的表格（复杂）"></p><p>表格内容多，格式复杂。最重要的是在要求表格为文字宽度后，内容根本看不清楚。</p><p>对于 tabular 教程，知乎有一篇不错。学会 tabular 可以更快地掌握 tabularx。当然，不会 tabular 不影响你继续看下去。（<a href="https://zhuanlan.zhihu.com/p/406538024">保姆级LaTeX教程|插入表格</a>）</p><p>在开始之前，我先推荐赶时间的同学们用下面这个网站自动化生成表格吧，使用 tabular 完成简单的表格是够用的。（<a href="https://www.tablesgenerator.com/">Tables Generator</a>）</p><p>少说废话，我们开始吧！</p><h2 id="tabularx-使用"><a href="#tabularx-使用" class="headerlink" title="tabularx 使用"></a>tabularx 使用</h2><p>从一个简单的例子开始吧。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;tabularx&#125;&#123;0.8<span class="hljs-keyword">\textwidth</span>&#125; &#123; <br>  | &gt;&#123;<span class="hljs-keyword">\raggedright</span><span class="hljs-keyword">\arraybackslash</span>&#125;X <br>  | &gt;&#123;<span class="hljs-keyword">\centering</span><span class="hljs-keyword">\arraybackslash</span>&#125;X <br>  | &gt;&#123;<span class="hljs-keyword">\raggedleft</span><span class="hljs-keyword">\arraybackslash</span>&#125;X <br>  | &#125;<br>  <span class="hljs-keyword">\hline</span><br>  abc <span class="hljs-built_in">&amp;</span> edf <span class="hljs-built_in">&amp;</span> ghi<span class="hljs-keyword">\\</span><br>  <span class="hljs-keyword">\hline</span><br>  edf <span class="hljs-built_in">&amp;</span> abc <span class="hljs-built_in">&amp;</span> ghi<span class="hljs-keyword">\\</span><br>  <span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\end</span>&#123;tabularx&#125;<br></code></pre></td></tr></table></figure><p>结果如下图。</p><p><img src="https://s3.uuu.ovh/imgs/2022/12/11/21c95b1758fa9e1d.png"></p><p>和 tabular 表格一样，整个表格环境从<code>\begin&#123;tabularx&#125;</code>开始，于<code>\end&#123;tabularx&#125;</code>结束。与 tabular 不同，第二个参数由大括号包裹，设置整个表格的宽度。在本例中，宽度为 0.8 的文字宽度；当然，这个文字宽度肯定不是 abc egf ghi 的宽度，<code>\textwidth</code>是整个页面中一行满满的文字的宽度，而 0.8 自然代表只有 80% 的宽度啦，你还可以是<code>0.5\textwidth</code>或者干脆占满宽度<code>\textwidth</code>（可别傻乎乎的写个<code>1\textwidth</code>，但也许也行？）。</p><p>那么，后面的 <code>| &gt;&#123;\raggedright\arraybackslash&#125;X</code>是什么呢？让我们进入 tabularx 的关键 X 吧！</p><h2 id="X"><a href="#X" class="headerlink" title="X"></a>X</h2><p>如果你学会了 tabular，你一定知道<code>&#123;|l|c|r|&#125;</code>是什么意思。不会也没关系，我教你啊。</p><p>我们用 <code>|</code> 产生表格中的竖线，而<code>l</code>是要求这一列左对齐，<code>c</code> 是居中对齐，<code>r</code> 是右对齐。那么，<code>&#123;|l|c|r|&#125;</code>表示，表格有三列，从左到右依次是：左对齐、居中对齐、右对齐。同时，表格最外围的竖线和表内的竖线都要手动用 <code>|</code> 产生，如果写成了 <code>&#123;l|c|r&#125;</code> 的话，表格最外面的边框是不存在的！</p><p><code>tabularx</code>兼容以上写法，同时定义了一个新的字母—— 大写的 <code>X</code>。使用 X 指定的列，将会自动换行并向左对齐。那么，向右对齐呢？居中对齐呢？</p><p>我们知道<code>\raggedrigh</code>和<code>\centering</code>分别对应了向<strong>左</strong>对齐（参差不齐的右边即左对齐）、居中对齐。但在 tabularx 中不能直接使用，他们会破坏换行符<code>\\</code>。为此，tabularx 定义了 <code>\arraybackslash</code> 来解决这个问题。使用方法就是直接加在后面，比如 <code>&gt;&#123;\raggedright\arraybackslash&#125;X</code> 就是进行<strong>左</strong>对齐，<code>&gt;</code>和<code>&#123;&#125;</code>不能少！</p><p><strong>每一个 tabularx 表格至少要有一个 X 列！</strong>虽然兼容 l,c,r 写法，但纯  l,c,r 组成的 tabularx 表格会出错的！</p><h2 id="单元格与横线"><a href="#单元格与横线" class="headerlink" title="单元格与横线"></a>单元格与横线</h2><p>每一个单元格使用<code>&amp;</code>分开，空格不是必须的。<code>abc&amp;def</code>和 <code>abc &amp; def</code> 的效果一致。换行使用 <code>\\</code> 完成，但每一行之间的横线不会自动生成，使用<code>\hline</code>手动生成吧！</p><p>如果要希望横线只占满几个格子，请使用<code>\cline&#123;begin-end&#125;</code>代替<code>\hline</code>。比如<code>\cline&#123;2-3&#125;</code>将只在从左向右数第 2、3 格下产生横线。</p><h2 id="标题与表格居中"><a href="#标题与表格居中" class="headerlink" title="标题与表格居中"></a>标题与表格居中</h2><p>tabularx 表格是可以嵌入 tabular 表格中的！没想到吧😀。这波是齐心努力，做大做强。</p><p>位于内部的表格最好用<code>&#123;&#125;</code>包裹起来。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;table&#125;[]<br>  <span class="hljs-keyword">\centering</span><br>  <span class="hljs-keyword">\caption</span>&#123;0.8 textwidth&#125;<span class="hljs-keyword">\label</span>&#123;tab:dummy-1&#125;<br>  &#123;<br>    <span class="hljs-keyword">\begin</span>&#123;tabularx&#125;&#123;0.8<span class="hljs-keyword">\textwidth</span>&#125; &#123;<br>        | &gt;&#123;<span class="hljs-keyword">\raggedright</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        | &gt;&#123;<span class="hljs-keyword">\centering</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        | &gt;&#123;<span class="hljs-keyword">\raggedleft</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        |&#125;<br>      <span class="hljs-keyword">\hline</span><br>      abc <span class="hljs-built_in">&amp;</span> edf <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>      <span class="hljs-keyword">\hline</span><br>      edf <span class="hljs-built_in">&amp;</span> abc <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>      <span class="hljs-keyword">\hline</span><br>    <span class="hljs-keyword">\end</span>&#123;tabularx&#125;<br>  &#125;<br><span class="hljs-keyword">\end</span>&#123;table&#125;<br></code></pre></td></tr></table></figure><p>利用 tabular 实现标题与表格居中，内部的表格绘制由 tabularx 完成。</p><p>下面的图或许可以帮助你更好的理解上文<img src="https://s3.uuu.ovh/imgs/2022/12/11/06318002edc10b2e.png"></p><p>代码如下</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-comment">%%%%%% 错误示范 %%%%%%%</span><br><span class="hljs-keyword">\begin</span>&#123;tabularx&#125;&#123;0.8<span class="hljs-keyword">\textwidth</span>&#125; &#123;|c|c|c|&#125;<br>  <span class="hljs-keyword">\hline</span><br>  abc<span class="hljs-built_in">&amp;</span>edf <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>  <span class="hljs-keyword">\cline</span>&#123;2-3&#125;<br>  edf <span class="hljs-built_in">&amp;</span> abc <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>  <span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\end</span>&#123;tabularx&#125;<br><span class="hljs-comment">%%%%%%% 错误示范结束 %%%%%%%%</span><br><span class="hljs-keyword">\begin</span>&#123;table&#125;[!ht]<br>  <span class="hljs-keyword">\centering</span><br>  <span class="hljs-keyword">\caption</span>&#123;0.8 textwidth&#125;<span class="hljs-keyword">\label</span>&#123;tab:dummy-1&#125;<br>  &#123;<br>    <span class="hljs-keyword">\begin</span>&#123;tabularx&#125;&#123;0.8<span class="hljs-keyword">\textwidth</span>&#125; &#123;|X|X|X|&#125;<br>      <span class="hljs-keyword">\hline</span><br>      abc <span class="hljs-built_in">&amp;</span> edf <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>      <span class="hljs-keyword">\cline</span>&#123;2-3&#125;<br>      edf <span class="hljs-built_in">&amp;</span> abc <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>      <span class="hljs-keyword">\hline</span><br>    <span class="hljs-keyword">\end</span>&#123;tabularx&#125;<br>  &#125;<br><span class="hljs-keyword">\end</span>&#123;table&#125;<br><span class="hljs-comment">%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="hljs-keyword">\begin</span>&#123;table&#125;[!ht]<br>  <span class="hljs-keyword">\centering</span><br>  <span class="hljs-keyword">\caption</span>&#123;0.5 textwidth&#125;<span class="hljs-keyword">\label</span>&#123;tab:dummy-1&#125;<br>  &#123;<br>    <span class="hljs-keyword">\begin</span>&#123;tabularx&#125;&#123;0.5<span class="hljs-keyword">\textwidth</span>&#125; &#123;<br>        | &gt;&#123;<span class="hljs-keyword">\raggedright</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        | &gt;&#123;<span class="hljs-keyword">\centering</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        | &gt;&#123;<span class="hljs-keyword">\raggedleft</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        |&#125;<br>      <span class="hljs-keyword">\hline</span><br>      abc <span class="hljs-built_in">&amp;</span> edf <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>      <span class="hljs-keyword">\hline</span><br>      edf <span class="hljs-built_in">&amp;</span> abc <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>      <span class="hljs-keyword">\hline</span><br>    <span class="hljs-keyword">\end</span>&#123;tabularx&#125;<br>  &#125;<br><span class="hljs-keyword">\end</span>&#123;table&#125;<br><span class="hljs-comment">%%%%%%%%%%%%%%%%%%%%%</span><br><span class="hljs-keyword">\begin</span>&#123;table&#125;[!ht]<br>  <span class="hljs-keyword">\centering</span><br>  <span class="hljs-keyword">\caption</span>&#123;1 textwidth&#125;<span class="hljs-keyword">\label</span>&#123;tab:dummy-1&#125;<br>  &#123;<br>    <span class="hljs-keyword">\begin</span>&#123;tabularx&#125;&#123;<span class="hljs-keyword">\textwidth</span>&#125; &#123;<br>        | &gt;&#123;<span class="hljs-keyword">\raggedright</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        | &gt;&#123;<span class="hljs-keyword">\centering</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        | &gt;&#123;<span class="hljs-keyword">\raggedleft</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        |&#125;<br>      <span class="hljs-keyword">\hline</span><br>      abc <span class="hljs-built_in">&amp;</span> edf <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>      <span class="hljs-keyword">\hline</span><br>      edf <span class="hljs-built_in">&amp;</span> abc <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>      <span class="hljs-keyword">\hline</span><br>    <span class="hljs-keyword">\end</span>&#123;tabularx&#125;<br>  &#125;<br><span class="hljs-keyword">\end</span>&#123;table&#125;<br></code></pre></td></tr></table></figure><h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h3 id="X-列的不同宽度"><a href="#X-列的不同宽度" class="headerlink" title="X 列的不同宽度"></a>X 列的不同宽度</h3><p>通常，单个表中的所有 X 列都设置为相同的宽度，但是可以让 tabularx 将它们设置为不同的宽度。下面是文档中的例子。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&#123;<br>  &gt;&#123;\hsize<span class="hljs-operator">=</span>.<span class="hljs-number">5</span>\hsize\linewidth<span class="hljs-operator">=</span>\hsize&#125;X<br>  &gt;&#123;\hsize<span class="hljs-operator">=</span><span class="hljs-number">1.5</span>\hsize\linewidth<span class="hljs-operator">=</span>\hsize&#125;X<br>&#125; <br></code></pre></td></tr></table></figure><p>指定两列，第二列的宽度是第一列的三倍。但是，如果你想进行这种神奇地操作，则应遵循以下两条规则。</p><ul><li>确保所有 X 列的宽度之和保持不变。（在上面的示例中，新宽度加起来仍然是默认宽度的两倍，即等于两个标准宽度相同 X 列）</li><li>不要使用跨越任何 X 列的 \multicolumn</li></ul><h2 id="看看效果"><a href="#看看效果" class="headerlink" title="看看效果"></a>看看效果</h2><p><img src="https://s3.uuu.ovh/imgs/2022/12/11/ddef4fb8e67f2cac.png"></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;table&#125;[]<br>  <span class="hljs-keyword">\centering</span><br>  <span class="hljs-keyword">\caption</span>&#123;测试&#125;<span class="hljs-keyword">\label</span>&#123;tab:dummy-1&#125;<br>  &#123;<br>    <span class="hljs-keyword">\begin</span>&#123;tabularx&#125;&#123;<span class="hljs-keyword">\textwidth</span>&#125; &#123;<br>        | &gt;&#123;<span class="hljs-keyword">\raggedright</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        | &gt;&#123;<span class="hljs-keyword">\centering</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        | &gt;&#123;<span class="hljs-keyword">\raggedleft</span><span class="hljs-keyword">\arraybackslash</span>&#125;X<br>        |&#125;<br>      <span class="hljs-keyword">\hline</span><br>      指企业在工商行政管理部门登记的注册资金。其中由三项原则：1. 资本确定原则：企业设立时，必须明确规定企业的资本总额和投资者认缴的数额2. 资本充实原则：资本金的筹集应及时、足额3. 资本维持原则：在持续经营期间应保持资本金的完整性，不得随意增加、减少资本 <span class="hljs-built_in">&amp;</span> edf <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>      <span class="hljs-keyword">\hline</span><br>      edf <span class="hljs-built_in">&amp;</span> abc <span class="hljs-built_in">&amp;</span> ghi <span class="hljs-keyword">\\</span><br>      <span class="hljs-keyword">\hline</span><br>    <span class="hljs-keyword">\end</span>&#123;tabularx&#125;<br>  &#125;<br><span class="hljs-keyword">\end</span>&#123;table&#125;<br></code></pre></td></tr></table></figure><h2 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h2><p>tabularx 在搜索最佳列宽时必须多次生成表格，因此速度要慢得多。此外，表格地多次膨胀可能会破坏某些 TEX 结构。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://ctan.mirror.globo.tech/macros/latex/required/tools/tabularx.pdf">https://ctan.mirror.globo.tech/macros/latex/required/tools/tabularx.pdf</a></li><li><a href="https://zhuanlan.zhihu.com/p/406538024">https://zhuanlan.zhihu.com/p/406538024</a></li><li><a href="https://www.overleaf.com/learn/latex/Tables">https://www.overleaf.com/learn/latex/Tables</a></li><li><a href="https://latex.org/forum/viewtopic.php?t=5998">https://latex.org/forum/viewtopic.php?t=5998</a></li><li><a href="https://tex.stackexchange.com/questions/468363/when-should-the-tabularx-environment-be-used-or-not">https://tex.stackexchange.com/questions/468363/when-should-the-tabularx-environment-be-used-or-not</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>筹资管理</title>
    <link href="/post/84c550e2.html"/>
    <url>/post/84c550e2.html</url>
    
    <content type="html"><![CDATA[<h2 id="筹资分类"><a href="#筹资分类" class="headerlink" title="筹资分类"></a>筹资分类</h2><h3 id="按权益性质分类"><a href="#按权益性质分类" class="headerlink" title="按权益性质分类"></a>按权益性质分类</h3><ol><li>股权筹资——企业长期拥有，可以自主调配的资产；财务风险小、资本风险大</li><li>债务筹资——借贷、发行债券等方式，需还本付息；财务风险大、资本风险小</li><li>衍生工具筹资———两者混合</li></ol><span id="more"></span><h3 id="按是否经过金融机构分类"><a href="#按是否经过金融机构分类" class="headerlink" title="按是否经过金融机构分类"></a>按是否经过金融机构分类</h3><ol><li>直接筹资——直接与资金供应者协商（不渡让资金使用权）：发行股票、债券</li><li>间接筹资——通过金融机构（渡让资金使用权）：债务资金</li></ol><h3 id="内部与外部筹资"><a href="#内部与外部筹资" class="headerlink" title="内部与外部筹资"></a>内部与外部筹资</h3><ol><li>内部——利润</li><li>外部——发行股票、债券、借款</li></ol><h3 id="长期筹资与短期筹资"><a href="#长期筹资与短期筹资" class="headerlink" title="长期筹资与短期筹资"></a>长期筹资与短期筹资</h3><ol><li>长期筹资——一年期以上</li><li>短期筹资</li></ol><p><strong>我国企业筹资方式</strong>：</p><ol><li>吸收直接投资</li><li>发行股票</li><li>银行借贷</li><li>商业信用</li><li>发行债券</li><li>融资租赁</li><li>留存收益</li></ol><h1 id="下面稍微介绍每一类筹资类别"><a href="#下面稍微介绍每一类筹资类别" class="headerlink" title="下面稍微介绍每一类筹资类别"></a>下面稍微介绍每一类筹资类别</h1><h2 id="权益资金"><a href="#权益资金" class="headerlink" title="权益资金"></a>权益资金</h2><h3 id="企业资本金制度"><a href="#企业资本金制度" class="headerlink" title="企业资本金制度"></a>企业资本金制度</h3><p>权益资金是投资人的投资与企业本身的积累资金。书中有资本金、直接吸收投资、股票筹资三类。</p><h4 id="资本金"><a href="#资本金" class="headerlink" title="资本金"></a>资本金</h4><p>指企业在工商行政管理部门登记的注册资金。其中由三项原则：</p><ol><li>资本确定原则：企业设立时，必须明确规定企业的资本总额和投资者认缴的数额</li><li>资本充实原则：资本金的筹集应及时、足额</li><li>资本维持原则：在持续经营期间应保持资本金的完整性，不得随意增加、减少资本</li></ol><h4 id="吸收直接投资"><a href="#吸收直接投资" class="headerlink" title="吸收直接投资"></a>吸收直接投资</h4><p>有：吸收国家投资、吸收法人投资、吸收个人投资</p><p>可分为：</p><ol><li>现金投资</li><li>实物投资</li><li>工业产权投资</li><li>土地使用权投资</li></ol><p>优点：</p><ol><li>增强企业信誉</li><li>尽快形成生产能力</li><li>降低财务风险</li></ol><p>缺点：</p><ol><li>资金成本较高</li><li>不利于产权流动</li><li>企业控制权容易分散</li></ol><h4 id="股票筹资"><a href="#股票筹资" class="headerlink" title="股票筹资"></a>股票筹资</h4><p>股票分为普通股与优先股。</p><p>普通股：有管理权、股利不固定，但有稳定的股息；以其出资份额承担经营损失与经济责任。</p><h2 id="长期债务资金的筹集"><a href="#长期债务资金的筹集" class="headerlink" title="长期债务资金的筹集"></a>长期债务资金的筹集</h2><h3 id="长期借款"><a href="#长期借款" class="headerlink" title="长期借款"></a>长期借款</h3><p>从银行、信托公司、财务公司获得的信用贷款（无抵押物品）、抵押贷款。</p><p>特点是：</p><ol><li>筹资速度快</li><li>借款弹性大</li><li>借款成本低</li><li>长期借款的限制比短期借款多</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>财务管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(Debian)-常见加固技巧（SSH）</title>
    <link href="/post/4828448e.html"/>
    <url>/post/4828448e.html</url>
    
    <content type="html"><![CDATA[<p>就在前几天，我朋友托管在我这的 TeamSpeak 服务器突然无法访问了。简单分析后决定更新 TeamSpeak，但在打包文件到本地整理的时候卡巴斯基突然报毒</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs llvm">team.tar\team\.configrc\a\a<span class="hljs-comment">;检测到恶意对象</span><br>检测到<span class="hljs-comment">;team.tar\team\.configrc\a\</span><br>a文件<span class="hljs-comment">;活动用户</span><br>Trojan.Shell.Agent.<span class="hljs-keyword">br</span><span class="hljs-comment">;数据库;木马程序;高;确切</span><br>检测到<span class="hljs-comment">;2022/11/1 23:08</span><br></code></pre></td></tr></table></figure><p>突然意识到事情不对，检查 SSH 日志发现为 teamspeak 单独建立的普通账户有一次远程登录。显然，服务器被黑了。详细检查后基本确定为<a href="https://guanjia.qq.com/news/n1/2574.html">亡命徒（Outlaw）</a>的变种。因此在这记录 SSH 常见的加固技巧。</p><span id="more"></span><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>ssh 作为服务器必备组件，公网上各种自动化工具针对 22 端口高强度扫描。而 ssh 的常见加固手段有：</p><ol><li>用高端口代替 22 端口</li><li>使用密钥认证代替密码登录</li><li>使用密码也用高强度密码</li></ol><h3 id="更改-SSH-端口，开启密钥登录"><a href="#更改-SSH-端口，开启密钥登录" class="headerlink" title="更改 SSH 端口，开启密钥登录"></a>更改 SSH 端口，开启密钥登录</h3><p>Debian 下 ssh 的配置文件分别是 &#x2F;etc&#x2F;ssh&#x2F;sshd_config 和 &#x2F;etc&#x2F;ssh&#x2F;sshd_config.d&#x2F;*.conf。其中 &#x2F;etc&#x2F;ssh&#x2F;sshd_config 为默认配置文件，不建议修改。我们自定义的文件位于 &#x2F;etc&#x2F;ssh&#x2F;sshd_config.d&#x2F; 且以 .conf 结尾。<br>下面新建一个配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">touch</span> /etc/ssh/sshd_config.d/my.conf<br></code></pre></td></tr></table></figure><p>文件内容如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Port</span> <span class="hljs-number">4309</span><br>PubkeyAuthentication <span class="hljs-literal">yes</span><br>PermitRootLogin <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><p>Port 4309 表示 SSH 换用 4309 端口。PubkeyAuthentication yes 表示开启密钥登录。PermitRootLogin yes 表示允许 root 登录，是否允许 root 登录见仁见智。</p><p>更换端口后使用 -p 指定登录的端口，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh root@192.168.43.2 -p 4309<br></code></pre></td></tr></table></figure><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p>使用密钥登录需要生成密钥对，先在<strong>本地机器</strong>运行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">&quot;your_email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>如果你的机器比较新，也可以使用 ed25519 算法，命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t ed25519 -C <span class="hljs-string">&quot;your_email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>SSH 会询问你一些问题：</p><ol><li>密钥储存位置，默认为用户目录下的 .ssh 目录</li><li>是否要为密钥添加密码，添加后每次使用要手动输入密码解锁密钥，如果不希望添加密码直接回车</li><li>确认密码，希望无密码继续回车</li></ol><p>下面是运行过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">Generating public/private ed25519 key pair.<br>Enter file <span class="hljs-keyword">in</span> <span class="hljs-built_in">which</span> to save the key (C:\Users\king/.ssh/id_ed25519):<br>Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase):<br>Enter same passphrase again:<br>Your identification has been saved <span class="hljs-keyword">in</span> C:\Users\king/.ssh/id_ed25519.<br>Your public key has been saved <span class="hljs-keyword">in</span> C:\Users\king/.ssh/id_ed25519.pub.<br>The key fingerprint is:<br>SHA256:zuN/3FgL12mtKYA3+deN4KA8UZmD7QrZSqouZv5HWDc your_email@example.com<br>The key<span class="hljs-string">&#x27;s randomart image is:</span><br><span class="hljs-string">+--[ED25519 256]--+</span><br><span class="hljs-string">|                 |</span><br><span class="hljs-string">|                 |</span><br><span class="hljs-string">|         o o     |</span><br><span class="hljs-string">|     . E. *      |</span><br><span class="hljs-string">|    o .oS+ o   .o|</span><br><span class="hljs-string">|   . .+o+ B o ooo|</span><br><span class="hljs-string">|    .o ++= B B.*.|</span><br><span class="hljs-string">|.o  ....=.  B B o|</span><br><span class="hljs-string">|+++o.   .o.. o   |</span><br><span class="hljs-string">+----[SHA256]-----+</span><br></code></pre></td></tr></table></figure><p>完成后于用户的 .ssh 目录下生成以算法命名的两文件，本例中为 id_ed25519 和 id_ed25519.pub。其中 id_ed25519 为私钥，请妥善保管，不要泄露；id_ed25519.pub 为公钥，准备上传至服务器。俩文件其实就是文本，用文本编辑器可以直接查看内容。下面是我刚刚生成的公钥内容</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">ssh-ed<span class="hljs-number">25519</span> AAAAC<span class="hljs-number">3</span><span class="hljs-symbol">NzaC1</span>lZDI<span class="hljs-number">1</span><span class="hljs-symbol">NTE5</span>AAAAI<span class="hljs-symbol">NnKAEj8</span>kC<span class="hljs-number">3</span>Uw<span class="hljs-number">5</span>tizK<span class="hljs-number">5</span>zg<span class="hljs-symbol">nPmQefx8</span>XWPVBECHxsx<span class="hljs-number">4</span>LhT your_email@example.com<br></code></pre></td></tr></table></figure><h3 id="上传密钥"><a href="#上传密钥" class="headerlink" title="上传密钥"></a>上传密钥</h3><p>SSH 要求将公钥保存在每个用户的 ~&#x2F;.ssh&#x2F;authorized_keys 中。比如准备将生成的密钥用以登录 test 用户，即将公钥内容粘贴进 test 的 ~&#x2F;.ssh&#x2F;authorized_keys 文件中即可。没有 authorized_keys 就手动创建。</p><p>注意，authorized_keys文件的权限要设为644，即只有文件所有者才能写。如果权限设置不对，SSH 服务器可能会<strong>拒绝</strong>读取该文件。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">chmod <span class="hljs-number">644</span> ~<span class="hljs-regexp">/.ssh/</span>authorized_keys<br></code></pre></td></tr></table></figure><p>完成后重启 sshd 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart sshd<br></code></pre></td></tr></table></figure><p>登录服务器，应该会自动登录。也可以查看日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/log/auth.log | grep <span class="hljs-string">&#x27;Accepted&#x27;</span><br></code></pre></td></tr></table></figure><p>应该出现类似内容</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Nov</span>  <span class="hljs-number">3</span> <span class="hljs-number">15</span>:<span class="hljs-number">35</span>:<span class="hljs-number">45</span> iZeio043iZ sshd[<span class="hljs-number">7356</span>]: Accepted publickey for test from <span class="hljs-number">193.104.113.211</span> port <span class="hljs-number">56834</span> ssh2: RSA SHA256:eg5UsdfmWUDimck1ozg+KDoMwIZbwMtejUHILTyg<br></code></pre></td></tr></table></figure><h3 id="禁用密码登录"><a href="#禁用密码登录" class="headerlink" title="禁用密码登录"></a>禁用密码登录</h3><p>如果成功使用密钥登录了，下面可以禁用密码登录以提高安全性。编辑上文创建的 &#x2F;etc&#x2F;ssh&#x2F;sshd_config.d&#x2F;my.conf 文件，添加一行</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">PasswordAuthentication</span> <span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><p>即可禁用密码登录。</p><h2 id="Fail2Ban"><a href="#Fail2Ban" class="headerlink" title="Fail2Ban"></a>Fail2Ban</h2><blockquote><p>Fail2Ban是一个入侵检测系统框架，它可以保护电脑服务器免受蛮力攻击。以Python程序设计语言编写，并能够在类Unix系统上运行，这些系统具有本地安装的数据包控制系统或防火墙的接口，例如Iptables或TCP Wrapper。 ——维基百科</p></blockquote><p>Fail2Ban 通过检查日志确定黑名单，通过 Iptables 进行禁封一定时间。</p><h3 id="安装与准备"><a href="#安装与准备" class="headerlink" title="安装与准备"></a>安装与准备</h3><p>首先是最简单的安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br>sudo apt install fail2ban<br></code></pre></td></tr></table></figure><p>安装完成后检查是否启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl status fail2ban<br></code></pre></td></tr></table></figure><p>正常运行结果如下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">● fail2ban.service - Fail2Ban Service<br>     Loaded: loaded (<span class="hljs-regexp">/lib/</span>systemd<span class="hljs-regexp">/system/</span>fail2ban.service; enabled; vendor preset: enabled)<br>     Active: active (running) since Wed <span class="hljs-number">2022</span>-<span class="hljs-number">11</span>-<span class="hljs-number">02</span> <span class="hljs-number">00</span>:<span class="hljs-number">26</span>:<span class="hljs-number">47</span> CST; <span class="hljs-number">1</span> day <span class="hljs-number">11</span>h ago<br>       Docs: man:fail2ban(<span class="hljs-number">1</span>)<br>    Process: <span class="hljs-number">10748</span> ExecStartPre=<span class="hljs-regexp">/bin/m</span>kdir -p <span class="hljs-regexp">/run/</span>fail2ban (code=exited, status=<span class="hljs-number">0</span>/SUCCESS)<br>   Main PID: <span class="hljs-number">10749</span> (fail2ban-server)<br>      Tasks: <span class="hljs-number">5</span> (limit: <span class="hljs-number">2335</span>)<br>     Memory: <span class="hljs-number">15.5</span>M<br>        CPU: <span class="hljs-number">36.352</span>s<br>     CGroup: <span class="hljs-regexp">/system.slice/</span>fail2ban.service<br>             └─<span class="hljs-number">10749</span> <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/python3 /u</span>sr<span class="hljs-regexp">/bin/</span>fail2ban-server -xf start<br><br>Nov <span class="hljs-number">02</span> <span class="hljs-number">00</span>:<span class="hljs-number">26</span>:<span class="hljs-number">47</span> VM-<span class="hljs-number">20</span>-<span class="hljs-number">6</span>-debian systemd[<span class="hljs-number">1</span>]: Starting Fail2Ban Service...<br>Nov <span class="hljs-number">02</span> <span class="hljs-number">00</span>:<span class="hljs-number">26</span>:<span class="hljs-number">47</span> VM-<span class="hljs-number">20</span>-<span class="hljs-number">6</span>-debian systemd[<span class="hljs-number">1</span>]: Started Fail2Ban Service.<br>Nov <span class="hljs-number">02</span> <span class="hljs-number">00</span>:<span class="hljs-number">26</span>:<span class="hljs-number">47</span> VM-<span class="hljs-number">20</span>-<span class="hljs-number">6</span>-debian fail2ban-server[<span class="hljs-number">10749</span>]: Server ready<br></code></pre></td></tr></table></figure><p>Fail2ban 在安装时会创建两个默认的配置文件 &#x2F;etc&#x2F;fail2ban&#x2F;jail.d&#x2F;defaults-debian.conf 和 &#x2F;etc&#x2F;fail2ban&#x2F;jail.conf 。我不建议直接修改这些文件，因为更新 Fail2ban 时它们可能会被覆盖。</p><p>Fail2ban 将按以下顺序读取配置文件。每个 .local 文件都会覆盖 .conf 文件中的设置：</p><ol><li>&#x2F;etc&#x2F;fail2ban&#x2F;jail.conf</li><li>&#x2F;etc&#x2F;fail2ban&#x2F;jail.d&#x2F;*.conf</li><li>&#x2F;etc&#x2F;fail2ban&#x2F;jail.local</li><li>&#x2F;etc&#x2F;fail2ban&#x2F;jail.d&#x2F;*.local</li></ol><p>因此我们直接将默认配置复制到 &#x2F;etc&#x2F;fail2ban&#x2F;jail.d&#x2F; 然后进行修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cp</span> /etc/fail2ban/jail.&#123;conf,<span class="hljs-built_in">local</span>&#125;<br>sudo vim /etc/fail2ban/jail.local<br></code></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h4><p>首先是白名单配置，白名单里的 ip 永远不会被禁封。如果你有其他固定 ip 可以添加进来，没有也可以直接跳过这个步骤。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ignoreip</span> = <span class="hljs-number">127.0.0.1</span>/<span class="hljs-number">8</span> ::<span class="hljs-number">1</span> <span class="hljs-number">192.168.1.0</span>/<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><h4 id="禁封条件与时间"><a href="#禁封条件与时间" class="headerlink" title="禁封条件与时间"></a>禁封条件与时间</h4><p>bantime，findtime 和 maxretry 设置了禁止时间和禁止条件。bantime是禁止持续的时间。如果未指定后缀则默认为秒，要永久禁止IP，请使用负数。findtime 是设置失败次数之间的持续时间。例如，如果将 Fail2ban 设置为在尝试五次失败后禁止IP，则这些失败必须在 findtime 时间内发生。maxretry 是IP失败尝试次数。默认值设置为5。下面是设置为10分钟完成5次失败，禁封 1 天。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">bantime</span>  <span class="hljs-operator">=</span> <span class="hljs-number">1</span>d<br><span class="hljs-attribute">findtime</span>  <span class="hljs-operator">=</span> <span class="hljs-number">10</span>m<br><span class="hljs-attribute">maxretry</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Jail 描述如何检测服务的条件。其中服务是系统的任意服务，比如 sshd 服务。条件是包括过滤器和操作。计算符合搜索模式的日志记录，并在满足预定条件时执行相应的操作。</p><p>Fail2ban 附带许多 Jail 作为示例，系统每一项服务都可以找到对应Jail配置。我们还可以创建自己的 Jail 配置。默认情况下，在CentOS 8上没有启用Jail。要启用 Jail，您需要在添加 enabled &#x3D; true。以下示例显示了如何为sshd服务启用Jail。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[sshd]</span><br><span class="hljs-attr">enabled</span>   = <span class="hljs-literal">true</span><br><span class="hljs-attr">port</span>    = <span class="hljs-number">4309</span><br><span class="hljs-attr">logpath</span> = %(sshd_log)s<br><span class="hljs-attr">backend</span> = %(sshd_backend)s<br></code></pre></td></tr></table></figure><p>因为上文中将 ssh 的登录端口改为 4309，因此这里的端口同样修改为 4309。<br>重启 Fail2Ban 使配置生效。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://wangdoc.com/ssh/key">https://wangdoc.com/ssh/key</a></li><li><a href="https://www.myfreax.com/install-configure-fail2ban-on-ubuntu-20-04/">https://www.myfreax.com/install-configure-fail2ban-on-ubuntu-20-04/</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>折腾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Adguard Home 设置</title>
    <link href="/post/ce8e32b9.html"/>
    <url>/post/ce8e32b9.html</url>
    
    <content type="html"><![CDATA[<p>Adguard Home 是 Windows 下最好的 DNS 管理器！会看见这篇文章，想必你对 Adguard Home 的功能已经有所了解，但我要泼一盆冷水， Adguard Home 的广告过滤功能比较鸡肋，效果不如浏览器的 uBlock Origin 插件好。但如果将其当作一个 DNS 管理器，它将十分优秀。本文主要介绍如何将 Adguard Home 部署在 Windows 下并为本机提供 DNS 服务。</p><span id="more"></span><p>在官方<a href="https://github.com/AdguardTeam/AdGuardHome/releases">Github 仓库</a>中选择适合 Windows 的版本，或者点击这下载<a href="https://github.com/AdguardTeam/AdGuardHome/releases/download/v0.107.13/AdGuardHome_windows_amd64.zip">AdGuardHome_windows_amd64.zip(v0.107)</a>。解压至一个好找的地方(别放在桌面，设置完后一不小心删了会无法联网)</p><p>文件如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">Mode                 LastWriteTime         Length Name<br>----                 -------------         ------ ----<br>-----           <span class="hljs-number">2022</span><span class="hljs-regexp">/9/</span><span class="hljs-number">14</span>    <span class="hljs-number">22</span>:<span class="hljs-number">46</span>       <span class="hljs-number">33306112</span> AdGuardHome.exe<br>-----           <span class="hljs-number">2022</span><span class="hljs-regexp">/9/</span><span class="hljs-number">14</span>    <span class="hljs-number">22</span>:<span class="hljs-number">46</span>            <span class="hljs-number">587</span> AdGuardHome.exe.sig<br>-----           <span class="hljs-number">2022</span><span class="hljs-regexp">/9/</span><span class="hljs-number">14</span>    <span class="hljs-number">22</span>:<span class="hljs-number">46</span>          <span class="hljs-number">51429</span> CHANGELOG.md<br>-----           <span class="hljs-number">2022</span><span class="hljs-regexp">/9/</span><span class="hljs-number">14</span>    <span class="hljs-number">22</span>:<span class="hljs-number">46</span>          <span class="hljs-number">35149</span> LICENSE.txt<br>-----           <span class="hljs-number">2022</span><span class="hljs-regexp">/9/</span><span class="hljs-number">14</span>    <span class="hljs-number">22</span>:<span class="hljs-number">46</span>          <span class="hljs-number">23266</span> README.md<br></code></pre></td></tr></table></figure><p>首次运行需要以管理员身份运行 AdGuardHome.exe，等命令行跑完。直到出现类似下面的命令</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">info</span>] Service control action: install<br>[<span class="hljs-keyword">info</span>] Service has been started<br>[<span class="hljs-keyword">info</span>] Almost ready!<br>AdGuard Home <span class="hljs-keyword">is</span> successfully installed <span class="hljs-keyword">and</span> will automatically <span class="hljs-keyword">start</span> <span class="hljs-keyword">on</span> boot ．<br>There are a few more things that must be configured <span class="hljs-keyword">before</span> you can use it.<br>lick <span class="hljs-keyword">on</span> the link below <span class="hljs-keyword">and</span> follow the Installation Wizard steps finish setup.<br>[<span class="hljs-keyword">info</span>] AdGuard Home <span class="hljs-keyword">is</span> available <span class="hljs-keyword">on</span> the f0110 丽 ng addresses ：<br>[<span class="hljs-keyword">info</span>] GO <span class="hljs-keyword">to</span> http://<span class="hljs-number">192.168</span><span class="hljs-number">.11</span>:<span class="hljs-number">3000</span><br>[<span class="hljs-keyword">info</span>] Go <span class="hljs-keyword">to</span> http://[::<span class="hljs-number">1</span>]:<span class="hljs-number">3000</span><br>[<span class="hljs-keyword">info</span>] Go <span class="hljs-keyword">to</span> http://<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">3000</span><br>[<span class="hljs-keyword">info</span>] Action install has been done successfully <span class="hljs-keyword">on</span> windows-service<br></code></pre></td></tr></table></figure><h2 id="Adguard-Home-设置"><a href="#Adguard-Home-设置" class="headerlink" title="Adguard Home 设置"></a>Adguard Home 设置</h2><p>在浏览器中输入 <a href="http://127.0.0.1:3000/">http://127.0.0.1:3000</a> 即可进入 Adguard Home 的管理页面，首先设置账号和密码，一路下一步即可，然后进入“DNS 设置”。</p><p><img src="https://s3.bmp.ovh/imgs/2022/09/29/eea15e9eae345f58.png"></p><p>在上游DNS服务器中填入以下内容，即可设置阿里DNS与腾讯DNS为上游 DoH 解析，同时 DoH 的 DNS 可以有效防止运营商的 DNS 污染。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>dns.alidns.com/dns-query<br>https:<span class="hljs-regexp">//</span>doh.pub/dns-query<br></code></pre></td></tr></table></figure><p>在 Bootstrap DNS 中填入，使用阿里DNS和GoogleDNS作为 DoH 服务器解析 DNS。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">223</span>.<span class="hljs-number">5</span>.<span class="hljs-number">5</span>.<span class="hljs-number">5</span><br><span class="hljs-attribute">8</span>.<span class="hljs-number">8</span>.<span class="hljs-number">8</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">2001</span>:<span class="hljs-number">4860</span>:<span class="hljs-number">4860</span>::<span class="hljs-number">8888</span><br><span class="hljs-attribute">2400</span>:<span class="hljs-number">3200</span>::<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2022/09/29/5f98fdce140013c7.png"></p><p>同时强烈推荐你丢弃 IPv6 解析，目前许多老小区的网络设施无法使用 IPv6，防止 Windows 使用 IPv6 去访问目标服务器。</p><p><img src="https://s3.bmp.ovh/imgs/2022/09/29/1328ec16d4029d8b.png"></p><p>其余默认即可。</p><p>DNS 过滤名单如下添加即可，太多不但拖慢速度而且效果不明显。</p><p><img src="https://s3.bmp.ovh/imgs/2022/09/29/a56ff7dec97a56e1.png"></p><h2 id="Windows-设置"><a href="#Windows-设置" class="headerlink" title="Windows 设置"></a>Windows 设置</h2><p>Adguard Home 的自带的设置指导已经十分详细。对于 Windows 步骤如下。</p><ol><li>通过开始菜单或 Windows 搜索功能打开控制面板。</li><li>点击进入「网络和 Internet」后，再次点击进入「网络和共享中心」</li><li>在窗口的左侧点击「更改适配器设置」。</li><li>选择您正在连接的网络设备，右击它并选择「属性”」。</li><li>在列表中找到「Internet 协议版本 4 (TCP&#x2F;IPv4)」，选择并再次点击「属性」。</li><li>选择「使用下面的 DNS 服务器地址」，并输入您的 AdGuard Home 服务器地址（127.0.0.1）。</li></ol><p><img src="https://s3.bmp.ovh/imgs/2022/09/29/a4391d4dc0860f91.png"></p><h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><p>在计划任务中新建任务，按下图填入（用户名要填你自己电脑登陆的用户名！！）<br><img src="https://s3.bmp.ovh/imgs/2022/09/29/80bee65439cc057c.png"><br><img src="https://s3.bmp.ovh/imgs/2022/09/29/3d2771b4a2d150b1.png"><br>程序就选择 Adguard Home.exe<br><img src="https://s3.bmp.ovh/imgs/2022/09/29/e70fb333adcf0d0e.png"><br><img src="https://s3.bmp.ovh/imgs/2022/09/29/42c16ecf60c06269.png"><br><img src="https://s3.bmp.ovh/imgs/2022/09/29/08dddfddb7e47d96.png"></p><p>完成</p>]]></content>
    
    
    
    <tags>
      
      <tag>折腾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现分配固定大小内存池-C++</title>
    <link href="/post/e678ff2a.html"/>
    <url>/post/e678ff2a.html</url>
    
    <content type="html"><![CDATA[<h2 id="内存池简述"><a href="#内存池简述" class="headerlink" title="内存池简述"></a>内存池简述</h2><blockquote><p>内存池（Memory Pool），又被称为固定大小区块规划（fixed-size-blocks allocation），允许程序员以类似 C语言 的 malloc 或是 C++ 的 new 操作数进行动态的存储器规划。对于其它动态存储器规划的实践来说，因为会变动存储器区块大小导致的碎片问题，导致在实时系统上受限于性能因此，根本无法使用。内存池提供了一个更有效率的解决方案：预先规划一定数量的存储器区块，使得整个程序可以在执行期规划 (allocate)、使用 (access)、归还 (free) 存储器区块。 ——维基百科</p></blockquote><span id="more"></span><h2 id="实现设计"><a href="#实现设计" class="headerlink" title="实现设计"></a>实现设计</h2><p>编写一个<code>MyMemoryPool</code>类作为内存池，<code>MyMemoryPool</code>类参照 C++ 标准库中的 <a href="https://zh.cppreference.com/w/cpp/memory/allocator">std::allocator</a> 设计。核心是维护两条链表：内存块表 (open_list)、分配后被释放而产生的重分配链表 (free_memory)。</p><p>内存块表设计如图</p><p><img src="https://s3.bmp.ovh/imgs/2022/09/26/cce4cd26feb2dd5f.png" alt="内存块表"></p><p>一次性申请一大块内存，然后在头部开辟表头，用以储存之前的内存头地址。剩余部分划分为多个固定大小的区块，将成为真正的内存分配区域。</p><p>重分配链表 (free_memory) 构成如图</p><p><img src="https://s3.bmp.ovh/imgs/2022/09/26/12d0fab63da20fda.png" alt="重分配链表"></p><p>重分配链表不含表头区域，完全是由待分配的内存构成。</p><p>内存分配步骤为：</p><ol><li>检查重分配链表 (free_memory) 是否有内存</li><li>若有直接分配重分配链表的内存，若无准备分配内存块表的内存</li><li>检查内存块表的空闲空间是否足够分配所需内存</li><li>若空闲空间不足，申请新的内存块表；否则直接分配内存块表的内存</li></ol><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="基础建设"><a href="#基础建设" class="headerlink" title="基础建设"></a>基础建设</h3><p>根据 <a href="https://zh.cppreference.com/w/cpp/memory/allocator">allocator</a> 的要求，我的目标是完成 C++11 的部分标准且我的类名为 <code>MyMemoryPool</code>。因此首先实现几个别名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> value_type = T;<br><span class="hljs-keyword">using</span> potinter = T *;<br><span class="hljs-keyword">using</span> const_pointer = <span class="hljs-type">const</span> T *;<br><span class="hljs-keyword">using</span> reference = T &amp;;<br><span class="hljs-keyword">using</span> const_reference = <span class="hljs-type">const</span> T &amp;;<br><span class="hljs-keyword">using</span> size_type = <span class="hljs-type">size_t</span>;<br></code></pre></td></tr></table></figure><p>由于标准没有对构造函数进行具体要求，我直接使用默认构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">MyMemoryPool</span>() &#123;&#125;<br><span class="hljs-built_in">MyMemoryPool</span>(<span class="hljs-type">const</span> MyMemoryPool &amp;other) &#123;&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-built_in">MyMemoryPool</span>(<span class="hljs-type">const</span> MyMemoryPool&lt;U&gt; &amp;other) &#123;&#125;<br></code></pre></td></tr></table></figure><p>rebind 是为了应对类似 std::list 的容器，这类容器在往往要求分配的是一个结构而不是储存的类型，比如 <code>std::list&lt;int,std::allocator&lt;int&gt;&gt;</code> 会在内部将 <code>std::allocator&lt;int&gt;</code> 改为 <code>std::allocator&lt;node&lt;int&gt;&gt;</code> 而 node 对调用 list 的人是不可见的，因此 <code>allocator</code> 需要提供 <code>rebind</code> 使 list 能自行更改指定的分配器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rebind</span> &#123; <span class="hljs-keyword">typedef</span> MyMemoryPool&lt;U&gt; other; &#125;;<br></code></pre></td></tr></table></figure><p>下面将是 private 部分，即我自己的实现细节。首先为方便理解变量的具体含义，定义几个类型别名、结构、指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> block_size = <span class="hljs-number">1024lu</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>  T *data;<br>  Node *next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> Node *block_pointer;<br><span class="hljs-keyword">typedef</span> Node *memory_pointer;<br><span class="hljs-keyword">typedef</span> T *data_pointer;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> *byte_pointer;<br>block_pointer open_list;<br>memory_pointer current;<br>memory_pointer free_memory;<br>memory_pointer end;<br></code></pre></td></tr></table></figure><p><code>block_size</code>是每次申请的内存块大小，<code>Node</code>用于充当内存块头和空闲内存分配区，<code>block_pointer</code>指向当前正在分配的内存块头，<code>current</code>指向即将分配的空闲内存块，<code>free_memory</code>是释放后产生的空闲内存，<code>end</code>为当前内存块表的最后一个内存地址</p><h3 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h3><p>根据 <a href="https://zh.cppreference.com/w/cpp/memory/allocator/allocate">成员函数 allocate</a> 的要求，我原本应该实现一个可以一次分配多个内存块且根据 hint 指针进行调整的分配器，但为简化实现，我的分配器每次只分配一个内存区块且忽略 hint 指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">data_pointer <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, <span class="hljs-type">const</span> data_pointer hint = <span class="hljs-literal">nullptr</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (free_memory != <span class="hljs-literal">nullptr</span>) &#123;<br>    memory_pointer target = free_memory;<br>    free_memory = free_memory-&gt;next;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;data_pointer&gt;(target);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (current &gt;= end)<br>    <span class="hljs-built_in">new_block</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;data_pointer&gt;(current++);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先判断是否有释放后产生的空闲内存，有优先使用它，否则分配内存块表中的空闲内存。检查内存块表是否有剩余空间，若无申请新的内存块表，最后将指向空闲内存的<code>current</code>强制转换为数据指针后返回（后自增）。</p><h3 id="申请新的内存块表"><a href="#申请新的内存块表" class="headerlink" title="申请新的内存块表"></a>申请新的内存块表</h3><p>调用<code>operator new</code>从系统中获得一块固定大小的内存。由于<code>char</code>占用 1 字节，因此<code>char*</code>即指向 char 类型的指针是一字节一字节的操作，将其当作直接操作内存字节的指针而不是真的需要操作字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">padPointer</span><span class="hljs-params">(byte_pointer p, <span class="hljs-type">size_t</span> align)</span> <span class="hljs-type">const</span> </span>&#123;<br> <span class="hljs-type">uintptr_t</span> result = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(p);<br> <span class="hljs-keyword">return</span> ((align - result) % align);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">new_block</span><span class="hljs-params">()</span> </span>&#123;<br> byte_pointer target = <span class="hljs-built_in">static_cast</span>&lt;byte_pointer&gt;(::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(block_size));<br> <span class="hljs-built_in">reinterpret_cast</span>&lt;block_pointer&gt;(target)-&gt;next = open_list;<br> open_list = <span class="hljs-built_in">reinterpret_cast</span>&lt;block_pointer&gt;(target);<br> byte_pointer body = target + <span class="hljs-built_in">sizeof</span>(block_pointer);<br> <span class="hljs-type">size_t</span> bodyPadding = <span class="hljs-built_in">padPointer</span>(body, <span class="hljs-built_in">alignof</span>(Node));<br> current = <span class="hljs-built_in">reinterpret_cast</span>&lt;memory_pointer&gt;(body + bodyPadding);<br> end = <span class="hljs-built_in">reinterpret_cast</span>&lt;memory_pointer&gt;(target + block_size -<span class="hljs-built_in">sizeof</span>(Node) + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>target</code>指向新申请的连续空闲内存，同时在头部生成一个Node结构充当内存块头，并将 next 指向旧内存块。<code>body</code>指向内存块头 (Node) 的末尾，padPointer 函数的存在是因为“内存对齐”的要求。</p><p>内存对齐是一个基础却复杂的概念，简单来说“数据项仅仅能存储在地址是数据项大小的整数倍的内存位置上”。alignof 能够返回查询类型的对齐要求，padPointer 则返回 p 与对齐地址的距离。也许你更常看见</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(x) + <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(<span class="hljs-number">7u</span>)) &amp; ~<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">size_t</span>&gt;(<span class="hljs-number">7u</span>);<br></code></pre></td></tr></table></figure><p>即返回将 <code>x</code> 转化为 <code>unsigned long int</code> 后的 8 的倍数。这也是进行内存对齐。</p><h3 id="释放元素"><a href="#释放元素" class="headerlink" title="释放元素"></a>释放元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(data_pointer p, <span class="hljs-type">size_t</span> n = <span class="hljs-number">1</span>)</span> </span>&#123;<br> <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">nullptr</span>) &#123;<br>   <span class="hljs-built_in">reinterpret_cast</span>&lt;memory_pointer&gt;(p)-&gt;next = free_memory;<br>   free_memory = <span class="hljs-built_in">reinterpret_cast</span>&lt;memory_pointer&gt;(p);<br> &#125;<br></code></pre></td></tr></table></figure><p>将 p 加入 free_memory 并忽略参数 n。</p><h2 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MY_MEMORYPOOL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MY_MEMORYPOOL</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMemoryPool</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> block_size = <span class="hljs-number">1024lu</span>;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    T *data;<br>    Node *next;<br>  &#125;;<br>  <span class="hljs-keyword">typedef</span> Node *block_pointer;<br>  <span class="hljs-keyword">typedef</span> Node *memory_pointer;<br>  <span class="hljs-keyword">typedef</span> T *data_pointer;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> *byte_pointer;<br>  block_pointer open_list;<br>  memory_pointer current;<br>  memory_pointer free_memory;<br>  memory_pointer end;<br><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">padPointer</span><span class="hljs-params">(byte_pointer p, <span class="hljs-type">size_t</span> align)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-type">uintptr_t</span> result = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uintptr_t</span>&gt;(p);<br>    <span class="hljs-keyword">return</span> ((align - result) % align);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">new_block</span><span class="hljs-params">()</span> </span>&#123;<br>    byte_pointer target = <span class="hljs-built_in">static_cast</span>&lt;byte_pointer&gt;(::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(block_size));<br>    <span class="hljs-built_in">reinterpret_cast</span>&lt;block_pointer&gt;(target)-&gt;next = open_list;<br>    open_list = <span class="hljs-built_in">reinterpret_cast</span>&lt;block_pointer&gt;(target);<br>    byte_pointer body = target + <span class="hljs-built_in">sizeof</span>(block_pointer);<br>    <span class="hljs-type">size_t</span> bodyPadding = <span class="hljs-built_in">padPointer</span>(body, <span class="hljs-built_in">alignof</span>(Node));<br>    current = <span class="hljs-built_in">reinterpret_cast</span>&lt;memory_pointer&gt;(body + bodyPadding);<br>    end = <span class="hljs-built_in">reinterpret_cast</span>&lt;memory_pointer&gt;(target + block_size -<br>                                           <span class="hljs-built_in">sizeof</span>(Node) + <span class="hljs-number">1</span>);<br>  &#125;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">MyMemoryPool</span>()<br>      : <span class="hljs-built_in">open_list</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">current</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">free_memory</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">end</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>  <span class="hljs-function">data_pointer <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, <span class="hljs-type">const</span> data_pointer hint = <span class="hljs-literal">nullptr</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (free_memory != <span class="hljs-literal">nullptr</span>) &#123;<br>      memory_pointer target = free_memory;<br>      free_memory = free_memory-&gt;next;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;data_pointer&gt;(target);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (current &gt;= end)<br>      <span class="hljs-built_in">new_block</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;data_pointer&gt;(current++);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(data_pointer p, <span class="hljs-type">size_t</span> n = <span class="hljs-number">1</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-built_in">reinterpret_cast</span>&lt;memory_pointer&gt;(p)-&gt;next = free_memory;<br>      free_memory = <span class="hljs-built_in">reinterpret_cast</span>&lt;memory_pointer&gt;(p);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rebind</span> &#123; <span class="hljs-keyword">typedef</span> MyMemoryPool&lt;U&gt; other; &#125;;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://github.com/cacay/MemoryPool">https://github.com/cacay/MemoryPool</a></li><li><a href="https://zhuanlan.zhihu.com/p/280706845">https://zhuanlan.zhihu.com/p/280706845</a></li><li><a href="https://www.cnblogs.com/wgwyanfs/p/6733609.html">https://www.cnblogs.com/wgwyanfs/p/6733609.html</a></li><li><a href="https://zh.cppreference.com/w/cpp/language/alignof">https://zh.cppreference.com/w/cpp/language/alignof</a></li><li><a href="https://en.cppreference.com/w/cpp/memory/allocator">https://en.cppreference.com/w/cpp/memory/allocator</a></li><li><a href="https://stackoverflow.com/questions/1845482/what-is-uintptr-t-data-type">https://stackoverflow.com/questions/1845482/what-is-uintptr-t-data-type</a></li><li><a href="https://www.zhihu.com/question/25527491/answer/56571062">https://www.zhihu.com/question/25527491/answer/56571062</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划-入门（记忆搜索与逆序递推）</title>
    <link href="/post/48595c53.html"/>
    <url>/post/48595c53.html</url>
    
    <content type="html"><![CDATA[<p>本篇博文旨在进行动态规划的入门，介绍基础思想。动态规划是十分基础的思想，但其依旧有一定的难度，特别是对于像我这种非计算机专业且无竞赛经验的爱好者。</p><span id="more"></span><h2 id="动态规划简介"><a href="#动态规划简介" class="headerlink" title="动态规划简介"></a>动态规划简介</h2><p>动态规划本身并无实际意义，它更像一种思想与手段以解决问题。如果一个问题可以被分解为若干子问题，且子问题又可解决主问题，我应该考虑动态规划。</p><p>动态规划有四个关键：</p><ol><li>状态</li><li>状态转移</li><li>最优子结构</li><li>重叠子问题</li></ol><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>我们以力扣上最简单的动态规划为例（<a href="https://leetcode.cn/problems/climbing-stairs/">70.爬楼梯</a>）。</p><blockquote><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p></blockquote><p>输入：n &#x3D; 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶</li></ol><p>我先不考虑动态规划，以最简单朴素的思想去思考。我可以构建一个二叉树，左右子节点分别代表爬 1 或 2 个台阶。我以爬 4 阶为例，二叉树如图。<br><img src="https://s3.bmp.ovh/imgs/2022/09/02/eee24b9043e8d849.png" alt="二叉树"></p><p>如果了解回溯法，马上反应过来这种二叉树可以使用回溯法生成。实际上回溯法确实和动态规划有些交际，就我目前观察，只要求判断对错、输出个数常见动态规划；要求输出过程的只能回溯法生成了。</p><p>就算你不知道回溯法，相信你也能看出这幅图有很多地方是重复的。比如 1 节点的左子树不就是 2 节点的子树吗？相似的地方还有很多，这就是<code>重叠子问题</code>。在遍历时有大量的计算是重复的，动态规划实际上就是要解决<code>重叠子问题</code>。</p><p>为了解决重叠子问题，一般有两类：</p><ol><li>记忆化搜索</li><li>逆向递推</li></ol><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>记忆化搜索很简单，比如你先生成 1 节点的子树，然后去看看 1 的左子树 2 节点，然后先去 3 节点之后又去 4 节点。完成 1 节点的子树后，你实际上已经生成过一遍 2,3,4 节点的子树了，记下来，下次要查看 2,3,4 节点就直接调用记录即可，不用重新生成。</p><p>那么，如何根据已经储存的节点数据得到新的节点数据呢？这就是<code>状态</code>和<code>状态转移方程</code>的工作。</p><p>我设 node(x) 表示 x 台阶到 n 台阶的不同方法总数，即题目所求为 node(1)。这就是<code>状态</code>。</p><p>1 台阶能到达 2,3 台阶，因此它的状态为 2,3 状态相加。有 node(1)&#x3D;node(2)+node(3)，我将其扩展到一般状态 node(x)&#x3D;node(x+1)+node(x+2)，这就是<code>状态转移方程</code>。</p><p>现在我完成了动态规划的所有问题，就剩编码实现了。一个简单 C++ 的实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> node[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">memset</span>(node,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(node));<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(i&gt;=n) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(node[i]&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> node[i];<br>  <span class="hljs-keyword">return</span> node[i]+=<span class="hljs-built_in">dp</span>(i+<span class="hljs-number">1</span>)+<span class="hljs-built_in">dp</span>(i+<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>一行一行看，<code>int node[100]</code>定义了一个足够大的数组用以储存每一个节点的状态，node[1] 就是 1 台阶状态…</p><p><code>memset(node,0,sizeof(node))</code> 将 node 数组全部初始化为 0 ，这便是动态规划的初始化。</p><p><code>int n</code>储存目标台阶数。</p><p><code>dp</code>函数是动态规划的关键，<code>if(i&gt;=n) return 1</code>判断当前试图计算的台阶是否已经超过目标，即动态规划的边界条件。</p><p><code>if(node[i]&gt;0) return node[i]</code>如果希望计算的台阶状态已经计算过了，直接返回结果，实现<code>记忆化</code>。</p><p><code>return node[i]+=dp(i+1)+dp(i+2)</code>先根据状态转移方程计算当前台阶状态，这里利用了 c++ 赋值语句本身返回结果的特性少写了一行代码。</p><h2 id="逆序递推"><a href="#逆序递推" class="headerlink" title="逆序递推"></a>逆序递推</h2><p>记忆化搜索虽能解决问题，但不停递归比较慢，逆序搜索可以使用循环解决问题。</p><p>经过上面的分析，我的目标是解决递推时出现的大量重复计算。观察状态转移方程<code>node(x)=node(x+1)+node(x+2)</code>和二叉树，可以发现要计算一个节点就必须先求下一个节点，如果我直接从后往前计算，我也能防止重复计算。</p><p>下面是一个简单的 c++ 实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>  <span class="hljs-type">int</span> node[n+<span class="hljs-number">1</span>];<br>  <span class="hljs-built_in">memset</span>(node,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(node));<br>  node[n]=<span class="hljs-number">1</span>;<br>  node[n<span class="hljs-number">-1</span>]=<span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>    node[i]=node[i+<span class="hljs-number">1</span>]+node[i+<span class="hljs-number">2</span>];<br>  &#125;<br>  <span class="hljs-keyword">return</span> node[<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>依旧一行一行看，<code>int n</code>储存目标台阶数。</p><p><code>int node[n+1]</code>定义了一个数组用以储存每一个节点的状态，这里使用了 C 语言的可选功能可变数组，因此 g++ 和 clang++ 可以编译通过但 msvc 不行（力扣使用 clang++ 因此可以通过）。可以改为<code>int node[100]</code>以符合标准 C++。</p><p><code>memset(node,0,sizeof(node))</code> 将 node 数组全部初始化为 0 。<br><code>node[n]=1</code> 与 <code>node[n-1]=2</code> 分别表示最后一个台阶的状态为 1，倒数第二个台阶状态为 2。这三条代码完成了动态规划的初始化。</p><p>一个从后往前的循环，利用<code>状态转移方程</code>完美的完成了逆序递推。</p><p>最后返回结果。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，动态规划的基础算是打下了，但要完成动态规划的题目还要掌握一些数据结构和常见动态规划模型（状态转移方程）。我在最开始学习算法时就碰见了动态规划，那时我只自学了一些 c++ 和 python 的简单语法，数据结构和算法是两眼一抹黑。看见 memset 函数我都蒙了，因此动态规划很长一段时间是我的噩梦，现在我总算解决了。（笑</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>市场营销</title>
    <link href="/post/2fd2f140.html"/>
    <url>/post/2fd2f140.html</url>
    
    <content type="html"><![CDATA[<p>杂乱无章的总结了市场营销的简单知识点和框架</p><span id="more"></span><h2 id="市场营销"><a href="#市场营销" class="headerlink" title="市场营销"></a>市场营销</h2><ul><li>观念转变：从“生产-&gt;市场”到“市场-&gt;生产”</li></ul><h2 id="市场营销环境"><a href="#市场营销环境" class="headerlink" title="市场营销环境"></a>市场营销环境</h2><h3 id="微观营销环境"><a href="#微观营销环境" class="headerlink" title="微观营销环境"></a>微观营销环境</h3><ol><li>营销渠道企业</li><li>顾客</li><li>竞争者</li><li>公众</li></ol><h3 id="宏观营销环境"><a href="#宏观营销环境" class="headerlink" title="宏观营销环境"></a>宏观营销环境</h3><ol><li>人口环境</li><li>经济环境</li><li>文化环境</li><li>自然环境</li><li>科学与技术环境</li><li>政治法律环境</li></ol><h2 id="分析消费者市场"><a href="#分析消费者市场" class="headerlink" title="分析消费者市场"></a>分析消费者市场</h2><h3 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h3><ol><li>消费者购买决策过程</li><li>消费者个体因素</li><li>外在环境因素</li><li>市场营销因素</li></ol><h3 id="购买过程"><a href="#购买过程" class="headerlink" title="购买过程"></a>购买过程</h3><ol><li>确认问题</li><li>信息收集</li><li>备选产品评估</li><li>购买决策</li><li>购后过程</li></ol><h3 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h3><ul><li>消费者认知</li><li>需求与动机</li><li>生理因素</li><li>经济因素</li><li>生活方式</li><li>环境因素：参照群体、家庭与角色身份</li></ul><h2 id="营销调研"><a href="#营销调研" class="headerlink" title="营销调研"></a>营销调研</h2><p>运用科学有效的方式，整理和分析有关市场营销方面的信息，提出解决问题的意见。</p><h2 id="市场成长战略"><a href="#市场成长战略" class="headerlink" title="市场成长战略"></a>市场成长战略</h2><p>向新的客户销售现有产品，实现企业成长，包括产品新的用途。</p><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ul><li>地理：在新的地理区域销售现有产品</li><li>人口：向特定的人群销售现有产品</li><li>发现产品的新用途</li></ul><h2 id="市场细分"><a href="#市场细分" class="headerlink" title="市场细分"></a>市场细分</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>发现市场机会，选择目标市场，制定市场营销组合策略，提高企业竞争力，提高顾客忠诚度。根据消费者对产品的喜好不同分为：同质偏好、分散偏好、集中偏好。</p><h3 id="细分标准"><a href="#细分标准" class="headerlink" title="细分标准"></a>细分标准</h3><ul><li>地理因素</li><li>人口因素</li><li>行为因素</li><li>心理因素</li></ul><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul><li>可盈利性</li><li>可实现性</li><li>可衡量性</li><li>可区分性</li></ul><h3 id="市场选择"><a href="#市场选择" class="headerlink" title="市场选择"></a>市场选择</h3><ul><li>无差异性战略</li><li>差异性战略</li><li>集中性战略</li></ul><h3 id="应注意的问题"><a href="#应注意的问题" class="headerlink" title="应注意的问题"></a>应注意的问题</h3><ul><li>细分市场的关联性</li><li>按计划进入市场</li><li>目标市场的社会责任</li></ul><h2 id="产品线策略"><a href="#产品线策略" class="headerlink" title="产品线策略"></a>产品线策略</h2><ul><li>产品线延伸策略：全部或部分的改变原有产品的市场定位，有向下、向上、双向延伸三种</li><li>产品线现代化决策：对现有产品线的技术进行升级或改造</li><li>产品线特色化决策：选择一或两个产品项目打造独特特征，提升产品线形象，剔除利润减少的项目</li></ul><h2 id="产品组合"><a href="#产品组合" class="headerlink" title="产品组合"></a>产品组合</h2><p>企业提供给市场的全部产品组合与结构</p><h2 id="产品生命周期"><a href="#产品生命周期" class="headerlink" title="产品生命周期"></a>产品生命周期</h2><ol><li>引入阶段：消费者对产品不了解，产品的生产技术也不完善。这时从价格和策略两方面入手：快速掠夺、快速渗透、缓慢掠夺、缓慢渗透</li><li>成长阶段：消费者渐渐了解产品的特性，生产工艺较为成熟，同时大量竞争者进入市场。不断提高产品的质量，开发新的用途，适时调整市场战略，开拓新的销售渠道，加强促销环境并建立品牌偏好</li><li>成熟阶段：成长成熟期内渠道需求疲软，增长率缓慢，市场饱和，销量稳定；衰退成熟期，销售水平明显下降，用户偏爱发生转移。市场改良、产品改良、营销组合三选一</li><li>衰退期：销量迅速下降，坚守企业减少产品的附加服务，价格下降到最低点，削减促销预算。集中策略、维持策略、榨取策略</li></ol><h2 id="品牌的含义与作用"><a href="#品牌的含义与作用" class="headerlink" title="品牌的含义与作用"></a>品牌的含义与作用</h2><p>品牌用以识别某个销售者或某群销售者的产品或服务。品牌有助于促进产品销售，树立企业形象；品牌有利于保护品牌所有者的权益且约束企业不良行为，扩大产品组合有助于实施市场细分战略。</p><h2 id="影响定价的因素"><a href="#影响定价的因素" class="headerlink" title="影响定价的因素"></a>影响定价的因素</h2><ul><li>定价目标：维持生存、当期利润最大化、市场占有率最大化、产品质量最优化</li><li>产品成本</li><li>市场需求：在其他条件不变的情况下，市场需求增加，企业就有定制较高价格的可能</li><li>竞争者的产品与价格</li><li>相关法律政策</li></ul><h2 id="定价基本策略"><a href="#定价基本策略" class="headerlink" title="定价基本策略"></a>定价基本策略</h2><ul><li>折扣定价</li><li>地区定价</li><li>心理定价：声望定价、招徕定价</li><li>差别定价</li><li>撇脂定价</li><li>渗透定价</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Openssl生成并使用自签名CA证书（V3）</title>
    <link href="/post/90465f91.html"/>
    <url>/post/90465f91.html</url>
    
    <content type="html"><![CDATA[<p>最近在搭建局域网环境，涉及到 https 时需要使用自签名证书。走了很多弯路，甚至有人说局域网 IP 没法签发证书。根据我的测试，证书的颁发是自由的，甚至可以一张证书给所有<code>IP</code>签发，但<code>v1</code>证书签发 IP 似乎总是会引发不匹配错误，因此需要签发<code>V3</code>证书。  </p><span id="more"></span><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>V3 证书的签发需要固定的文件夹结构，这点和 V1 是不一样的。这个文件夹结构可以在<code>/etc/ssl/openssl.cnf</code>中查看。  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[ CA_default ]</span><br><span class="hljs-attr">dir</span>             = ./demoCA              <span class="hljs-comment"># 生成CA证书的工作目录</span><br><span class="hljs-attr">certs</span>           = <span class="hljs-variable">$dir</span>/certs            <span class="hljs-comment"># 保存生成的 ca 证书</span><br><span class="hljs-attr">crl_dir</span>         = <span class="hljs-variable">$dir</span>/crl              <span class="hljs-comment"># Where the issued crl are kept</span><br><span class="hljs-attr">database</span>        = <span class="hljs-variable">$dir</span>/index.txt        <span class="hljs-comment"># database index file.</span><br><span class="hljs-attr">new_certs_dir</span>   = <span class="hljs-variable">$dir</span>/newcerts         <span class="hljs-comment"># 保存用 CA 签发的其他证书，这里是 pem 格式的备份</span><br><br><span class="hljs-attr">certificate</span>     = <span class="hljs-variable">$dir</span>/cacert.pem       <span class="hljs-comment"># The CA certificate</span><br><span class="hljs-attr">serial</span>          = <span class="hljs-variable">$dir</span>/serial           <span class="hljs-comment"># The current serial number</span><br><span class="hljs-attr">crlnumber</span>       = <span class="hljs-variable">$dir</span>/crlnumber        <span class="hljs-comment"># the current crl number</span><br>                                        <span class="hljs-comment"># must be commented out to leave a V1 CRL</span><br><span class="hljs-attr">crl</span>             = <span class="hljs-variable">$dir</span>/crl.pem          <span class="hljs-comment"># The current CRL</span><br><span class="hljs-attr">private_key</span>     = <span class="hljs-variable">$dir</span>/private/cakey.pem<span class="hljs-comment"># The private key</span><br></code></pre></td></tr></table></figure><p>也就是说，如果你不手动配置的话，你的 CA 证书目录一定叫<code>demoCA</code> 且 demoCA 包含<code>private &amp; newcerts</code>两个子目录。CA 证书与密钥的文件名只能是<code>cacert.pem</code>与<code>cakey.pem</code>。</p><h2 id="生成目录结构"><a href="#生成目录结构" class="headerlink" title="生成目录结构"></a>生成目录结构</h2><p>先新建一个目录，我取名叫 CA 。然后运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ./demoCA/&#123;private,newcerts&#125; &amp;&amp; \<br>    <span class="hljs-built_in">touch</span> ./demoCA/index.txt &amp;&amp; \<br>    <span class="hljs-built_in">touch</span> ./demoCA/serial &amp;&amp; \<br>    <span class="hljs-built_in">echo</span> 01 &gt; ./demoCA/serial<br></code></pre></td></tr></table></figure><h2 id="签发CA证书"><a href="#签发CA证书" class="headerlink" title="签发CA证书"></a>签发CA证书</h2><p>创建 CA 配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> CA.cnf<br></code></pre></td></tr></table></figure><p>文件内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[ req ]</span><br> <br><span class="hljs-attr">default_bits</span>        = <span class="hljs-number">2048</span><br><span class="hljs-attr">default_keyfile</span>     = r.pem<br><span class="hljs-attr">default_md</span>          = sha256<br><span class="hljs-attr">string_mask</span>         = nombstr<br><span class="hljs-attr">distinguished_name</span>  = req_distinguished_name<br><span class="hljs-attr">req_extensions</span>      = req_ext<br><span class="hljs-attr">x509_extensions</span>     = x509_ext<br><span class="hljs-section">[ req_distinguished_name ]</span><br> <br><span class="hljs-attr">countryName</span>                 = Country Name (<span class="hljs-number">2</span> letter code)<br><span class="hljs-attr">countryName_default</span>         = CN<br><span class="hljs-attr">stateOrProvinceName</span>         = State or Province Name (full name)<br><span class="hljs-attr">stateOrProvinceName_default</span> = BeiJing<br><span class="hljs-attr">localityName</span>                = Locality Name (eg, city)<br><span class="hljs-attr">localityName_default</span>        = BeiJing<br><span class="hljs-attr">organizationName</span>            = Organization Name (eg, company)<br><span class="hljs-attr">organizationName_default</span>    = Hydrogen CA<br><span class="hljs-attr">commonName</span>                  = Common Name (e.g. server FQDN or YOUR name)<br><span class="hljs-attr">commonName_max</span>              = <span class="hljs-number">64</span><br><span class="hljs-attr">commonName_default</span>          = Hydrogen CA<br><span class="hljs-section">[ x509_ext ]</span><br> <br><span class="hljs-attr">subjectKeyIdentifier</span>   = hash<br><span class="hljs-attr">authorityKeyIdentifier</span> = keyid,issuer<br><span class="hljs-attr">basicConstraints</span>       = CA:<span class="hljs-literal">TRUE</span><br><span class="hljs-attr">keyUsage</span>               = digitalSignature, keyEncipherment, keyCertSign, cRLSign<br><span class="hljs-section">[ req_ext ]</span><br> <br><span class="hljs-attr">subjectKeyIdentifier</span> = hash<br><span class="hljs-attr">basicConstraints</span>     = CA:<span class="hljs-literal">TRUE</span><br><span class="hljs-attr">keyUsage</span>             = digitalSignature, keyEncipherment, keyCertSign, cRLSign<br><br></code></pre></td></tr></table></figure><p><code>countryName_default</code>是国家代码<br><code>organizationName_default</code>是证书机构的名称<br><code>commonName_default</code>是机构的友好名称<br>其他的可以不改</p><h3 id="生成CA证书"><a href="#生成CA证书" class="headerlink" title="生成CA证书"></a>生成CA证书</h3><p>生成 CA 证书密钥  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">openssl genrsa -out .<span class="hljs-regexp">/demoCA/</span><span class="hljs-keyword">private</span>/cakey.pem <span class="hljs-number">2048</span><br></code></pre></td></tr></table></figure><p>生成 CA 证书</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">openssl req -<span class="hljs-keyword">new</span> -x509 -key .<span class="hljs-regexp">/demoCA/</span><span class="hljs-keyword">private</span><span class="hljs-regexp">/cakey.pem -out ./</span>demoCA/cacert.pem -days <span class="hljs-number">3650</span> -config CA.cnf<br></code></pre></td></tr></table></figure><p>转化为 <code>cer</code>文件（可选）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">openssl x509 -inform PEM -<span class="hljs-keyword">in</span> .<span class="hljs-regexp">/demoCA/</span>cacert.pem -outform DER -out .<span class="hljs-regexp">/demoCA/</span>CA.cer<br></code></pre></td></tr></table></figure><h2 id="签发服务器证书"><a href="#签发服务器证书" class="headerlink" title="签发服务器证书"></a>签发服务器证书</h2><p>服务器证书的文件结构比较自由，命名也随意。我取为 test，下面配置服务器的配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> test.cnf<br></code></pre></td></tr></table></figure><p>内容如下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[ req ]</span><br> <br><span class="hljs-attr">default_bits</span>        = <span class="hljs-number">2048</span><br><span class="hljs-attr">default_keyfile</span>     = r.pem<br><span class="hljs-attr">default_md</span>          = sha256<br><span class="hljs-attr">string_mask</span>         = nombstr<br><span class="hljs-attr">distinguished_name</span>  = req_distinguished_name<br><span class="hljs-attr">req_extensions</span>      = req_ext<br><span class="hljs-attr">x509_extensions</span>     = x509_ext<br><span class="hljs-section">[ req_distinguished_name ]</span><br> <br><span class="hljs-attr">countryName</span>                 = Country Name (<span class="hljs-number">2</span> letter code)<br><span class="hljs-attr">countryName_default</span>         = CN<br><span class="hljs-attr">stateOrProvinceName</span>         = State or Province Name (full name)<br><span class="hljs-attr">stateOrProvinceName_default</span> = BeiJing<br><span class="hljs-attr">localityName</span>                = Locality Name (eg, city)<br><span class="hljs-attr">localityName_default</span>        = BeiJing<br><span class="hljs-attr">organizationName</span>            = Organization Name (eg, company)<br><span class="hljs-attr">organizationName_default</span>    = Hydrogen CA<br><span class="hljs-attr">commonName</span>                  = Common Name (e.g. server FQDN or YOUR name)<br><span class="hljs-attr">commonName_max</span>              = <span class="hljs-number">64</span><br><span class="hljs-attr">commonName_default</span>          = Hydrogen portainer<br><span class="hljs-section">[ x509_ext ]</span><br> <br><span class="hljs-attr">subjectKeyIdentifier</span>   = hash<br><span class="hljs-attr">authorityKeyIdentifier</span> = keyid,issuer<br><span class="hljs-attr">basicConstraints</span>       = CA:<span class="hljs-literal">FALSE</span><br><span class="hljs-attr">keyUsage</span>               = digitalSignature, keyEncipherment<br><span class="hljs-attr">subjectAltName</span> = @alt_names<br><span class="hljs-section">[ req_ext ]</span><br> <br><span class="hljs-attr">subjectKeyIdentifier</span> = hash<br><span class="hljs-attr">basicConstraints</span>     = CA:<span class="hljs-literal">FALSE</span><br><span class="hljs-attr">keyUsage</span>             = digitalSignature, keyEncipherment<br><span class="hljs-attr">subjectAltName</span> = @alt_names<br><span class="hljs-section">[ alt_names ]</span><br><br><span class="hljs-attr">IP.1</span>    = <span class="hljs-number">10.10</span>.<span class="hljs-number">11.10</span><br><br></code></pre></td></tr></table></figure><p><code>organizationName_default</code>需要与 CA 的一致。<br>域名和 IP 在 [alt_names] 中修改，例如</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">DNS.1</span>   = *.bing.com<br><span class="hljs-attr">DNS.2</span>   = bing.com<br><span class="hljs-attr">IP.1</span>    = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-attr">IP.2</span>    = <span class="hljs-number">10.10</span>.<span class="hljs-number">11.10</span><br></code></pre></td></tr></table></figure><p>生成服务器证书的储存目录</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">mkdir</span> <span class="hljs-keyword">my</span><br></code></pre></td></tr></table></figure><p>生成服务器密钥</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">openssl genrsa -<span class="hljs-keyword">out</span> my/<span class="hljs-keyword">test</span>.pem 2048<br></code></pre></td></tr></table></figure><p>生成描述文件</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">openssl req -new -key my/<span class="hljs-keyword">test</span>.pem -<span class="hljs-keyword">out</span> my/<span class="hljs-keyword">test</span>.csr -config <span class="hljs-keyword">test</span>.cnf<br></code></pre></td></tr></table></figure><p>签发证书</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">openssl <span class="hljs-keyword">ca</span> -<span class="hljs-keyword">in</span> my/<span class="hljs-keyword">test</span>.csr -<span class="hljs-keyword">out</span> my/<span class="hljs-keyword">test</span>.crt -days 365 -extensions x509_ext -extfile <span class="hljs-keyword">test</span>.cnf<br></code></pre></td></tr></table></figure><p>完成！<br>文件结构如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus">test<br>├── CA<span class="hljs-selector-class">.cnf</span><br>├── demoCA<br>│   ├── CA<span class="hljs-selector-class">.cer</span><br>│   ├── cacert<span class="hljs-selector-class">.pem</span><br>│   ├── index<span class="hljs-selector-class">.txt</span><br>│   ├── index<span class="hljs-selector-class">.txt</span><span class="hljs-selector-class">.attr</span><br>│   ├── index<span class="hljs-selector-class">.txt</span><span class="hljs-selector-class">.old</span><br>│   ├── newcerts<br>│   │   └── <span class="hljs-number">01</span><span class="hljs-selector-class">.pem</span><br>│   ├── private<br>│   │   └── cakey<span class="hljs-selector-class">.pem</span><br>│   ├── serial<br>│   └── serial<span class="hljs-selector-class">.old</span><br>├── my<br>│   ├── test<span class="hljs-selector-class">.crt</span><br>│   ├── test<span class="hljs-selector-class">.csr</span><br>│   └── test<span class="hljs-selector-class">.pem</span><br>└── test<span class="hljs-selector-class">.cnf</span><br><br></code></pre></td></tr></table></figure><h2 id="参考-amp-引用"><a href="#参考-amp-引用" class="headerlink" title="参考&amp;引用"></a>参考&amp;引用</h2><p>[1].<a href="https://2heng.xin/2018/12/16/your-own-ca-with-openssl/">https://2heng.xin/2018/12/16/your-own-ca-with-openssl/</a><br>这文章写的太好了，我只是略作改动<br>[2].<a href="https://docs.microsoft.com/zh-cn/azure/application-gateway/self-signed-certificates">https://docs.microsoft.com/zh-cn/azure/application-gateway/self-signed-certificates</a><br>生成 V1 的证书看微软的文档就够了</p>]]></content>
    
    
    
    <tags>
      
      <tag>折腾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>提取图片主要色调-KMeans算法</title>
    <link href="/post/2c6e351a.html"/>
    <url>/post/2c6e351a.html</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>K-Means 算法是一种十分常见的聚类分析方法，可将数据分为指定的几个集群。下面简述一下算法步骤。</p><h2 id="1-分配第一次中心"><a href="#1-分配第一次中心" class="headerlink" title="1.分配第一次中心"></a>1.分配第一次中心</h2><p>在数据中挑选几个点作为不同集群的中心，初次挑选的中心会影响最后的分组结果。如下图</p><span id="more"></span><p><img src="https://s3.bmp.ovh/imgs/2022/05/02/138b2a8616503882.png" alt="初次挑选"></p><h2 id="2-计算属于不同中心的数据"><a href="#2-计算属于不同中心的数据" class="headerlink" title="2.计算属于不同中心的数据"></a>2.计算属于不同中心的数据</h2><p>通常使用距离作为判断依据，数据点属于离它最近的中心<br><img src="https://s3.bmp.ovh/imgs/2022/05/02/4918839e9804c0f8.png">  </p><h2 id="3-移动中心"><a href="#3-移动中心" class="headerlink" title="3.移动中心"></a>3.移动中心</h2><p>将属于同一个中心的数据化为一集群，计算集群的新中心。我选择集群的平均值中心作为新中心，并将原中心移动到新的中心。<br><img src="https://s3.bmp.ovh/imgs/2022/05/02/f266de869362c93d.png"></p><h2 id="4-迭代"><a href="#4-迭代" class="headerlink" title="4.迭代"></a>4.迭代</h2><p>重复 2 和 3 步。直到发现中心不再变化，完成。<br><img src="https://s3.bmp.ovh/imgs/2022/05/02/7ea6a60254de97c0.png"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>我使用 Python 简单实现了一个例子，实际使用过程中更倾向直接调用 SciPY 的现成实现。</p><h3 id="生成随机数据"><a href="#生成随机数据" class="headerlink" title="生成随机数据"></a>生成随机数据</h3><p>在这简单填充随机生成的数据进行测试。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">k=<span class="hljs-number">0</span><br>date=np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">225</span>,size=[<span class="hljs-number">100</span>,<span class="hljs-number">2</span>])<br>dateList=[datePoint(i[<span class="hljs-number">0</span>],i[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> date]<br>pointlist=[[random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">225</span>),random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">225</span>)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k)]<br></code></pre></td></tr></table></figure><p><code>k</code> 为中心点个数；<code>date</code>为随机生成的数据；<code>dateList</code> 保存数据与其所属中心点；<code>pointlist</code> 是中心，使用随机数初始化。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">datePoint</span>:<br>  x=y=<span class="hljs-number">0</span><br>  point=<span class="hljs-number">0</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,X,Y,Point=<span class="hljs-number">0</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>      self.x=X<br>      self.y=Y<br>      self.point=Point<br></code></pre></td></tr></table></figure><p>我定义了一个类 <code>dateList</code> 与<code>datePoint.point</code>来储存数据点与它所属的中心。  </p><h3 id="计算数据点所属的中心"><a href="#计算数据点所属的中心" class="headerlink" title="计算数据点所属的中心"></a>计算数据点所属的中心</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calPoint</span>(<span class="hljs-params">dateList:<span class="hljs-built_in">list</span>,pointList:<span class="hljs-built_in">list</span></span>):<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dateList:<br>    flag=<span class="hljs-number">10000000</span> <span class="hljs-comment">#一个足够大的数字</span><br>    <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(pointList)):<br>      <span class="hljs-keyword">if</span>(flag&gt;((i.x-pointList[ii][<span class="hljs-number">0</span>])**<span class="hljs-number">2</span>+(i.y-pointList[ii][<span class="hljs-number">1</span>])**<span class="hljs-number">2</span>)):<br>        flag=(i.x-pointList[ii][<span class="hljs-number">0</span>])**<span class="hljs-number">2</span>+(i.y-pointList[ii][<span class="hljs-number">1</span>])**<span class="hljs-number">2</span><br>        i.point=ii<br></code></pre></td></tr></table></figure><p>遍历每一个数据点，在第二个循环中检查每一个中心到该点的距离，选择最小的那个。这里使用了一个足够大的数字保证第一次计算的距离会小于这个假想的中心点。  </p><h3 id="移动中心点"><a href="#移动中心点" class="headerlink" title="移动中心点"></a>移动中心点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">change_point</span>(<span class="hljs-params">dateList:<span class="hljs-built_in">list</span>,pointList:<span class="hljs-built_in">list</span></span>):<br>  new_point_list=[[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k)]<br>  nums_point=[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k)]<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dateList:<br>    new_point_list[i.point][<span class="hljs-number">0</span>]+=i.x<br>    new_point_list[i.point][<span class="hljs-number">1</span>]+=i.y<br>    nums_point[i.point]+=<span class="hljs-number">1</span><br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>    pr=new_point_list[i]<br>    pr[<span class="hljs-number">0</span>]=<span class="hljs-built_in">int</span>(pr[<span class="hljs-number">0</span>]/nums_point[i])<br>    pr[<span class="hljs-number">1</span>]=<span class="hljs-built_in">int</span>(pr[<span class="hljs-number">1</span>]/nums_point[i])<br>  <span class="hljs-keyword">if</span> new_point_list!=pointList:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>      pointList[i][<span class="hljs-number">0</span>]=new_point_list[i][<span class="hljs-number">0</span>]<br>      pointList[i][<span class="hljs-number">1</span>]=new_point_list[i][<span class="hljs-number">1</span>]<br>    <span class="hljs-built_in">print</span>(pointList)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>  <span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>先定义了一个数组 <code>new_point_list</code> 来储存新计算的中心点，然后 <code>nums_point</code> 储存属于每一个中心点的数据个数以方便最后计算平均值。在我这个精度下，点取整数即可。最后一个 <code>if</code> 用于判断中心发生了改变，就返回 <code>True</code> 反之为 <code>False</code>.</p><h3 id="一些收尾工作"><a href="#一些收尾工作" class="headerlink" title="一些收尾工作"></a>一些收尾工作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> change_point(dateList,pointlist):<br>  calPoint(dateList,pointlist)<br><span class="hljs-built_in">print</span>(pointlist)<br></code></pre></td></tr></table></figure><p>不停的迭代 2 和 3 步，直到中心不再移动。最后输出结果即可。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1].<a href="https://aishack.in/tutorials/kmeans-clustering/">https://aishack.in/tutorials/kmeans-clustering/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用加密的虚拟硬盘安全存储学习资料</title>
    <link href="/post/11014277.html"/>
    <url>/post/11014277.html</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>众所周知，21世纪的青少年到了一定的年纪总会积累下一大批的学习资料。如果你像我一样是属仓鼠的，你将不可避免的产生隐秘的储存学习资料的需求，除非你是社交恐怖分子。啥也不知道的新司机以为多重嵌套文件夹就万事大吉，最多启用隐藏文件夹。大部分老司机可能会选择使用加密的压缩包来储存资料，毕竟压缩包简单好使，如果没有经常复习的需求已经够用了。但如果你想更近一步，使用更加高级且舒适的方法，这文章值得你看下去。虽然准备稍复杂，但日后体验绝对很棒。  </p><span id="more"></span><p><strong>以下操作均在 Windows10&#x2F;11 下完成</strong>  </p><h2 id="创建虚拟硬盘"><a href="#创建虚拟硬盘" class="headerlink" title="创建虚拟硬盘"></a>创建虚拟硬盘</h2><p>虚拟硬盘是一种特殊的文件，它像其他文件比如PPT和图片一样可以自由复制或移动。但使用时只需 “挂载” ，计算机便会出现一个新的硬盘，对于应用程序来说它就是普通的硬盘，也就是说你该咋用就咋用，不碍事。好啦，下面我们来创建一个虚拟硬盘吧。<br>首先你要决定创建<strong>动态虚拟硬盘</strong>还是<strong>固定虚拟硬盘</strong>，下面简称为动态硬盘和固定硬盘。动态硬盘一开始占用空间很小，但随着填充内容会逐渐变大直到设定大小。固定硬盘的大小一开始就设定完成，不够用了可以手动扩充，但对于加密的硬盘来说扩充更加困难，优点是比动态硬盘性能好一些。  </p><h3 id="命令行创建（可能需要专业版）"><a href="#命令行创建（可能需要专业版）" class="headerlink" title="命令行创建（可能需要专业版）"></a>命令行创建（可能需要专业版）</h3><p><strong>确保下文的所有 PowerShell 命令以管理员身份运行</strong><br>创建动态硬盘（因为大小是动态增大的，设定值容量高一些比较好）：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">New</span>-VHD -<span class="hljs-type">Path</span> c:\base.vhdx -SizeBytes <span class="hljs-number">100</span>GB<br></code></pre></td></tr></table></figure><p>不出意外会C 盘根目录下产生一个 5MB 大小的base.vhdx文件<br>创建固定硬盘：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">New</span><span class="hljs-operator">-</span><span class="hljs-variable">VHD</span> <span class="hljs-operator">-</span><span class="hljs-built_in">Path</span> <span class="hljs-built_in">C</span><span class="hljs-operator">:</span>\<span class="hljs-variable">fixed</span><span class="hljs-operator">.</span><span class="hljs-variable">vhd</span> <span class="hljs-operator">-</span><span class="hljs-variable">Fixed</span> <span class="hljs-operator">-</span><span class="hljs-variable">SizeBytes</span> <span class="hljs-number">10</span><span class="hljs-variable">GB</span><br></code></pre></td></tr></table></figure><p>C盘根目录下产生一个 10GB 的fixed.vhd文件</p><h3 id="GUI创建"><a href="#GUI创建" class="headerlink" title="GUI创建"></a>GUI创建</h3><ul><li>   Win+x并点击磁盘管理</li><li>   单击 “操作（A）” 并选择 “创建VHD”<br><img src="https://s3.bmp.ovh/imgs/2022/04/29/5a40d0823c7ec9ab.png"></li><li>   位置随你喜欢，虚拟硬盘大小选择 GB 并且越大越好</li><li>   硬盘类型选择 “动态扩展” ，VHD 还是 VHDX 随你喜欢<br><img src="https://s3.bmp.ovh/imgs/2022/04/29/3c93432f669eba68.png"></li></ul><h2 id="格式化虚拟硬盘"><a href="#格式化虚拟硬盘" class="headerlink" title="格式化虚拟硬盘"></a>格式化虚拟硬盘</h2><p>这里统一使用GUI格式化<br>*右键新出现的硬盘，注意不要点到分区那里了<br><img src="https://s3.bmp.ovh/imgs/2022/04/29/fed1927d32b8ef12.png"><br>*初始化硬盘<br>*选择 MBR 和 GPT 其实差不多，但如果你的系统不是专业版，我推荐 MBR<br>*确定<br>*右键分区，新建简单卷，一直下一步，完成即可<br><img src="https://s3.bmp.ovh/imgs/2022/04/29/6ac80240d89cc854.png"><br>好了，现在你应该可以看见一块新的空硬盘了  </p><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>这里又有两个选则。如果你使用的是专业版系统，并且以后一定只在 Windows 环境下学习我推荐你选择 BitLocker 加密。这只适用于 Windows 系统但体验最好。如果你不是专业版或者以后也许会换 Mac 或者 Linux 环境，我要向你推荐大名鼎鼎的 VeraCrypt 加密软件。  </p><h3 id="Bitlocker加密"><a href="#Bitlocker加密" class="headerlink" title="Bitlocker加密"></a>Bitlocker加密</h3><ul><li>   在资源管理器之中右键新分区</li><li>   选择 “启用Bitlocker”</li><li>   设置密码</li><li>   选一个你喜欢的保存选项</li><li>   一直下一页，完成即可<br>Bitlocker 加密完成，下面的 VeraCrypt可以跳过。</li></ul><h3 id="VeraCrypt加密"><a href="#VeraCrypt加密" class="headerlink" title="VeraCrypt加密"></a>VeraCrypt加密</h3><ul><li>   (下载 VeraCrypt)<a href="https://launchpad.net/veracrypt/trunk/1.25.9/+download/VeraCrypt%20Portable%201.25.9.exe">https://launchpad.net/veracrypt/trunk/1.25.9/+download/VeraCrypt%20Portable%201.25.9.exe</a></li><li>   运行 VeraCrypt.exe<br><img src="https://s3.bmp.ovh/imgs/2022/04/29/16fbb54ae7ce942d.png"></li><li>   如果你是英语界面，选择 “Setting”-&gt;“language”找到中文即可</li><li>   单击 “加密卷”-&gt;“创建加密卷”</li><li>   “加密非系统分区&#x2F;设备”</li><li>   标准加密卷即可<br><img src="https://s3.bmp.ovh/imgs/2022/04/29/cc717be09776fa92.png"></li><li>   选择有 “新加卷” 且大小符合你设定值的硬盘</li><li>   下一步，直到 “加密选项”</li><li>   哈希算法一栏我推荐 “SHA-256”，毕竟越快越好<br><img src="https://s3.bmp.ovh/imgs/2022/04/29/2001ca89a75f33ef.png"></li><li>   下一步~</li><li>   填写密码</li><li>   大文件选择推荐 “是”</li><li>   进入 “加密卷格式化” 步骤后在小窗口内不停移动鼠标直到进度条变绿且跑满<br><img src="https://s3.bmp.ovh/imgs/2022/04/29/f81bac2c0df3dc40.png"></li><li>   格式化~等待一会，电脑可能会卡</li><li>   要仔细阅读警告哦!!!</li><li>   关掉窗口，已经加密完了</li></ul><h4 id="VeraCrypt挂载"><a href="#VeraCrypt挂载" class="headerlink" title="VeraCrypt挂载"></a>VeraCrypt挂载</h4><p>日后使用时，先按下文的步骤挂载虚拟硬盘，然后打开 VeraCrypt.exe 在 ABCDEF…… 里随便选一个，点击自动挂载设备，解密~完成！这里我解释一下为什么选择 MBR 硬盘：在我的电脑上，GPT 类型的硬盘自动挂载会卡很久，可能是因为多了一个引导分区导致的。反正这硬盘也不装系统，MBR 就很好用。</p><h2 id="挂载与弹出硬盘"><a href="#挂载与弹出硬盘" class="headerlink" title="挂载与弹出硬盘"></a>挂载与弹出硬盘</h2><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>win+x 进入磁盘管理，点击 “操作（A）”，选择 “附加VHD“ 找到虚拟硬盘文件即可。</p><h3 id="弹出硬盘"><a href="#弹出硬盘" class="headerlink" title="弹出硬盘"></a>弹出硬盘</h3><p>使用了 VeraCrypt 加密的同学，请先运行 VeraCrypt 并点击 “全部卸载“ 。之后再进入磁盘管理，右键虚拟磁盘，点击 ”分离VHD“，确定即可。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>经过以上操作，你已经掌握了高级的文件隐藏技巧。上述资料存储的进化过程是我的亲身经历，技术力不断进步，工具越来越复杂，但想在生活中更加舒适的愿望没有改变。可以说是不忘初心了（笑。相信掌握新方法的你日后学习一定能更上一层楼，去异世界之前再也不用拜托后辈清空硬盘了！</p>]]></content>
    
    
    
    <tags>
      
      <tag>折腾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原点</title>
    <link href="/post/b1be357.html"/>
    <url>/post/b1be357.html</url>
    
    <content type="html"><![CDATA[<h1 id="原点"><a href="#原点" class="headerlink" title="原点"></a>原点</h1><p>建站的第一篇文章，我应该写啥好呢？<br>算了，本来肚子里就没啥墨水，强行高雅只会引起自我厌恶。这次就一个目标，争取不要像上一个小站一样暴毙。<br>不过，我还是想说说上一个博客，顺便发发牢骚。反正除了爬虫也少有访问，这里权当一个“大胆的树洞”。</p><span id="more"></span>  <p>关于上一个博客，我用了一个小众的工具。当时我比现在还菜，特别喜欢图形界面，于是使用了 Gridea 作为根基。这是我从少数派上了解到的<br>一个“玩具”。不过我的博客和它一样，最开始很兴奋，然后慢慢的变成——“好麻烦啊！又没几个人用，算啦吧。”，最后就不更新了。这是很多博客和开源软件的命运，没有大量的用户和利益刺激，兴奋消退后只有自嘲。经过我的总结，这种情况大多数是因为过高的目标和期望所导致的。我们又不是少数大佬，隔几天就有超大的技术积累，超新颖的人生感悟，所以一开始就明白自己不会有太多的干货，摆正心态才能稳定更新！<strong>但坚决不转载，这种无意义的复制只会产生垃圾!</strong><br>注意，我不是过河拆桥哈。我其实很向往这种可以开发自己的软件然后还有人用的程序员生活，毕竟我估计是做不到了。现在的我一切从简，选择了HEXO 和 NexT 来搭建博客。我只希望这次博客可以稳定更新，至少一个月一篇吧。<br> 在我这，不可避免的会出现 “搭建日记，管理类笔记，算法知识，生活记录，游戏内容”。<br> 下面用狄兰·托马斯的《不要温和地走进那个良夜》结尾喽。  </p><blockquote><p>不要温和地走进那良夜，<br>老年应当在日暮时燃烧咆哮；<br>怒斥，怒斥光明的消逝。<br>虽然智慧的人临终时懂得黑暗有理，<br>因为他们的话没有迸发出闪电，<br>他们也并不温和地走进那个良夜。<br>善良的人，当最后一浪过去，高呼他们脆弱的善行<br>可能曾会多么光辉地在绿色的海湾里舞蹈，<br>怒斥，怒斥光明的消逝。<br>狂暴的人抓住并歌唱过翱翔的太阳，<br>懂得，但为时太晚，他们使太阳在途中悲伤，<br>也并不温和地走进那个良夜。<br>严肃的人，接近死亡，用炫目的视觉看出<br>失明的眼睛可以像流星一样闪耀欢欣，<br>怒斥，怒斥光明的消逝。<br>您啊，我的父亲。在那悲哀的高处。<br>现在用您的热泪诅咒我，祝福我吧。<br>我求您不要温和地走进那个良夜。<br>怒斥，怒斥光明的消逝。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/post/4a17b156.html"/>
    <url>/post/4a17b156.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
